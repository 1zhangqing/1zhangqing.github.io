<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>厦门银行一二面面经</title>
      <link href="/2022/10/22/sha-men-yin-xing-yi-er-mian-mian-jing/"/>
      <url>/2022/10/22/sha-men-yin-xing-yi-er-mian-mian-jing/</url>
      
        <content type="html"><![CDATA[<h1 id="厦门银行一二面面经"><a href="#厦门银行一二面面经" class="headerlink" title="厦门银行一二面面经"></a><center>厦门银行一二面面经</center></h1><p>一面：</p><p>1、自我介绍</p><p>2、站起来走到后面再走回来，看你的着装吧大概，还好那天穿了衬衫还扣上扣子了</p><p>3、实习中学习到了什么？</p><p>4、给自己的开发能力打几分？剩下的缺在哪？</p><p>5、有收到什么offer，有投其他银行吗，也都是科技岗吗？</p><p>6、觉得自己是一个什么性格的人？</p><p>7、成绩，专业多少人，拿奖学金要什么排名？</p><p>8、在校做的项目有一个是后端，一个是全栈是吧？然后我就展开讲我前后端都能负责（资本家听了都落泪）她没等我讲完就说好了好了进入下一个问题</p><p>9、没给反问机会，直接说面试到此结束，直接退出就行。</p><p>二面：</p><p>1、不用自我介绍直接开始</p><p>2、SpringMVC工作原理，整个的一个工作流程讲一下</p><p>3、dispatchServelet是用来干嘛的？我说是用来派发前端过来的请求的，问，如何实现派发前端请求的？</p><p>4、对AOP的了解？</p><p>5、进程间是如何通信的？</p><p>6、讲一下B+树。</p><p>7、技术面就结束了…接下来是HR面</p><p>8、对于工作地点的优先选择？是有很多亲戚在厦门吗？</p><p>9、还有考虑其他岗位吗？没有</p><p>10、反问（后面还有几轮？这是最后一轮面试，过了的话还有一个笔试。包住吗？有两年的住房还是住房补贴来着，好像是政府给的）</p><p>10.17一面–&gt;10.21二面，二面正好周五，笔试未发，不知道过没过。</p>]]></content>
      
      
      <categories>
          
          <category> Job Interview </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Job Interview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>恒生电子一二面面经</title>
      <link href="/2022/10/22/heng-sheng-dian-zi-yi-er-mian-mian-jing/"/>
      <url>/2022/10/22/heng-sheng-dian-zi-yi-er-mian-mian-jing/</url>
      
        <content type="html"><![CDATA[<h1 id="恒生电子一二面面经"><a href="#恒生电子一二面面经" class="headerlink" title="恒生电子一二面面经"></a><center>恒生电子一二面面经</center></h1><p>一面：</p><p>1、自我介绍</p><p>2、Java基础的数据类型以及包装类型？为什么要有包装类型？用法举例说明。</p><p>3、数据库删除记录怎么删。应该是要答三个关键字</p><p>4、Java有几种锁？</p><p>5、设计模式了解吗？应用场景？</p><p>6、Spring IOC和AOP的设计模式了解吗？</p><p>7、基础数据类型的包装类如果要保证线程安全的话有对应的包装类吗还是怎么解决的？</p><p>8、map接口下有那几个实现类？HashMap和HashTable有什么区别？哪个线程安全？CurrentHashMap的原理是什么？</p><p>9、如何防止用户页面刷新导致不断地发请求？</p><p>10、反问（公司技术栈？进去之后主要是做什么样的工作？要提前实习吗？）</p><p>二面：</p><p>1、自我介绍</p><p>2、遇到最大的压力是什么？吧啦一堆后问给这种压力打几分？（1-10）</p><p>3、最有成就感的事情？</p><p>4、觉得自己有没有组织领导能力？答有一定的领导能力吧啦吧啦，然后问要如何提升这种能力？</p><p>5、对于docker的理解？为什么用docker？和虚拟机这样的有什么区别？</p><p>6、为什么要划分微服务？有什么好处？一开始答便于分工，问单体的也能划分模块来分工啊。然后答各个微服务可以分别部署，集群部署来防止单个服务宕机导致的整体服务不可用。</p><p>7、Java是学校有相关课程还是自学的？为什么选择Java而不是C的方向？</p><p>8、哪里人？独生子女？如果让你去杭州那边，你的想法？家里不会说想让你离他们近一点吗？</p><p>9、薪资的要求？如何得出的这个薪资范围？</p><p>10、有什么是你比较不擅长到擅长的吗？举例说明。</p><p>11、反问（包住宿吗？不包。还有几轮？这是最后一轮。几天出结果？这一两天。）</p><p>9.24投递简历并笔试–&gt;10.12一面技术面–&gt;10.13测评（好像发测评就代表一面过了）–&gt;10.18二面HR面穿插几个技术问题–&gt;10.20发offer（一天内给答复，两天内寄出三方，特别急，违约金13k😓，六险一金，公积金12%）</p><p>给的虽然是白菜价，但是因为base在福州，已经差不多是福州第一档的应届生工资了，接了。</p>]]></content>
      
      
      <categories>
          
          <category> Job Interview </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Job Interview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>广州高新兴机器人一面</title>
      <link href="/2022/10/22/guang-zhou-gao-xin-xing-ji-qi-ren-yi-mian/"/>
      <url>/2022/10/22/guang-zhou-gao-xin-xing-ji-qi-ren-yi-mian/</url>
      
        <content type="html"><![CDATA[<h1 id="广州高新兴机器人一面"><a href="#广州高新兴机器人一面" class="headerlink" title="广州高新兴机器人一面"></a><center>广州高新兴机器人一面</center></h1><p>10.19一面，面完发了测评，应该是过了</p><p>1、自我介绍</p><p>2、String是基础的数据类型吗？</p><p><a href="https://blog.csdn.net/lu202032/article/details/117047712">(37条消息) Java中 String类的详解(非常全面细致)_路宇的博客-CSDN博客_java string</a></p><p>3、为什么String是不可变的呢？</p><p>4、Java的基础数据类型有几种？</p><p>5、对多线程有了解吗？创建线程的几种方式？</p><p><a href="https://xue.baidu.com/okam/pages/strategy/index?strategyId=138108026331130&source=natural">创建线程有哪几种方式-百度知了好学 (baidu.com)</a></p><p><a href="https://blog.csdn.net/qq_46111269/article/details/126140830">(37条消息) 创建线程的四种方式（Thread、Runnable、线程池、Callable）_歪嗯waien的博客-CSDN博客_创建线程有哪几种方式</a></p><p>6、HashMap和HashTable的区别有了解过吗？HashMap是有序的吗？不是。那用什么才能存储有序的呢？LinkedList。</p><p><a href="https://blog.csdn.net/FeiChangWuRao/article/details/120269168">(37条消息) 有序的HashMap：LinkedHashMap_我是坑货的博客-CSDN博客_有序hashmap</a></p><p><a href="https://www.csdn.net/tags/MtjaAg2sNTUzNTYtYmxvZwO0O0OO0O0O.html">(37条消息) hashmap如何实现有序 - CSDN</a></p><p>7、MySQL数据库的优化有做过哪些？</p><p><a href="https://blog.csdn.net/ThinPikachu/article/details/122152689">(37条消息) 数据库优化的四大方法_瘦弱的皮卡丘的博客-CSDN博客_数据库优化</a></p><p>8、有使用SpringCloud的是吧，讲一下它的几个核心组件以及对应的作用。</p><p>9、讲一下你在实习做的事情。</p><p>10、数组转换成集合有哪几种方式？</p><p><a href="https://blog.csdn.net/weixin_42327945/article/details/96131238">(37条消息) 小白入门之 数组转列表的4种方法_谢苏、的博客-CSDN博客_数组转列表</a></p><p>11、深拷贝和浅拷贝的区别？深拷贝的对象放在哪里？堆。</p><p>12、反问</p>]]></content>
      
      
      <categories>
          
          <category> Job Interview </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Job Interview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三棵树两面凉经</title>
      <link href="/2022/10/22/san-ke-shu-liang-mian-liang-jing/"/>
      <url>/2022/10/22/san-ke-shu-liang-mian-liang-jing/</url>
      
        <content type="html"><![CDATA[<h1 id="三棵树两面凉经"><a href="#三棵树两面凉经" class="headerlink" title="三棵树两面凉经"></a><center>三棵树两面凉经</center></h1><p>这公司太差劲了，看老家不是莆田的就把人刷了，要刷就刷，偏不在简历筛选时刷，整个笔试一二面的流程都走完了才刷，属实是给气到了，技术面也不刷人，明明要招Java的，来了几个前端和C++的面试也不刷掉，水到极致，问题答没答出来都给进二面，这样的面试有什么意义？线下面纯HR面，我还穿了西裤衬衫比较正式，最后感谢信了，真是谢谢您嘞。</p><p>10.11线上技术群面，按顺序一个一个面，我是第一个，8分钟左右结束</p><p>1、自我介绍</p><p>2、分布式事务是怎么解决的？答了消息队列可靠消息+最终一致性来解决，问有没有学过其他的？其他的没复习就说没有。</p><p>3、分布式锁是如何做的？</p><p>4、Java垃圾回收机制，青年代老年代分别的作用？这里把老年代说成了永久代，尴尬😅</p><p>然后…然后就结束了，质问我确定是永久代吗，语气很差，然后说他刚刚说的是老年代，然后我正想解释一下的，他问了一下旁边的人时间是不是到了，然后直接说下一个，我整一个大无语，反问都没有就算了，语气是真差劲</p><p>听了同组几个人的，两个福大硕士，这年头这破公司随机匹配一下都能随机匹配到两个福大硕，自我介绍都是SCI发了几篇几篇，在什么上发了多了论文啥的。</p><p>当时就觉得要没了，结果这俩一个是前端，一个是C++，但是，信息科技岗具体要求里写了要有Java、Web开发经验。</p><p>问前端的福大硕士：</p><p>Vue和React和Angular的区别？讲得挺好，一看就是背过的。</p><p>看你是前端的，会不会Java？他说不会，只会基础语法。</p><p>前端跟后端的交互过程中如何保证数据安全性？他不会。</p><p>问C++的福大硕士：</p><p>你是学C的，但是我们公司不招C的吧，我们公司主要是招Java的？（那简历初筛的时候为啥不筛，真是大无语，关键是技术面还给人过了，想让人转行是吧。）</p><p>有没有意向转Java？还是比较想做C++的。（人都这么说了，面试还不把他刷掉，无语）</p><p>对数据库的了解如何？了解不多</p><p>用C++做一个底层的保证安全性的一个啥玩意记不清了，怎么做？他说不知道。</p><p>好了，一个要Java的岗，来了两个非Java的，官网上只写信息科技岗确实可能投错，但是三棵树自己简历不筛就离谱了，技术面都这样子了，还让过，离大谱了属于是。</p><p>面试体验极其糟糕！</p><p>10.13大学城某酒店线下面</p><p>当时还不知道那俩不对口的进了，以为就是因为他俩不对口所以让我进了，说要穿正装，还穿了，还说面试进度比较快让提早去，结果去等了一个多小时，无语了。</p><p>而且以为第一轮技术面那么水，我还以为这一轮应该才是真正的技术面，想来锻炼锻炼的，结果是纯HR面😅</p><p>三个面试官，六个面试人员依次坐一排面，但我那组只有剩三个人了，很不幸我又是第一个</p><p>1、自我介绍</p><p>2、兴趣爱好？</p><p>3、三个词形容自己</p><p>4、对公司有什么要求？比较不能接受的三个点？</p><p>5、拿到什么offer？</p><p>好像还有几个但是我忘记是什么了。三个人按一个问题轮流答，总共也就面了不到15分钟。真是纯属浪费我的时间。垃圾公司。</p><p>总结：面试体验及其糟糕！面试官真的差劲。但HR小姐姐还是比较好的。但公司也是各垃圾公司，在我这里洗不白了。</p>]]></content>
      
      
      <categories>
          
          <category> Job Interview </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Job Interview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>中电福富面经</title>
      <link href="/2022/10/22/zhong-dian-fu-fu-mian-jing/"/>
      <url>/2022/10/22/zhong-dian-fu-fu-mian-jing/</url>
      
        <content type="html"><![CDATA[<h1 id="中电福富面经"><a href="#中电福富面经" class="headerlink" title="中电福富面经"></a><center>中电福富面经</center></h1><p>福州的福富是线下的二三十分钟结束，我当时投了厦门的，大家都收到我没有收到，还以为我连中电福富这垃圾公司的简历都过不了。</p><p>然后，厦门的标准明显比福州要高（但薪资居然不变？？？）厦门的面试人员面了我一个多小时。</p><p>9.29面–&gt;10.10意向</p><p>1、自我介绍</p><p>2、在校哪些课学得比较好？搁这给我挖坑呢，答了操作系统和组成原理吧好像还是数据库。</p><p>3、结果就是，开始问一些操作系统由哪几部分组成，有一个什么操作是什么忘记了，反正就算一些操作系统和组成原理的内容。（谁考完了还去看这玩意？会的不都是要考研的吗）</p><p>4、JVM垃圾回收机制讲一下</p><p>5、数据库查询总数用什么？count *。聚集呢？group by。排序呢？order by。</p><p>6、实习中做什么？问了一下实习项目相关。</p><p>7、docker都是怎么用的。举例一些命令。</p><p>8、介绍一下商城项目。</p><p>9、如何实现高并发的。</p><p>10、如何避免超卖的？</p><p>11、接口幂等性如何实现，即防止用户刷接口重复下单。（这个经常给问到）</p><p>12、分布式锁实现的原理？</p><p>13、能不能接受加班？</p><p>14、能不能接受出差？答可以，怕太假了，补充了一句，国内可以，然后问我那新疆西藏这样的呢？（我真的是无语极了！）</p><p>15、反问。</p><p>还有很多但是我忘得差不多了，反正基本上把我简历上有写到的都问了一遍，还有一开始的408。</p><p>还以为没了，但还是让我过了，真点击就送。但是厦门跟福州一个价，而且才6500左右，还要自备电脑就离谱，强制毕业前实习，实习不抵试用期，实习期考核没过他还能无条件解约就真是离谱。给了意向，拒了。</p>]]></content>
      
      
      <categories>
          
          <category> Job Interview </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Job Interview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>顶点软件一面凉经</title>
      <link href="/2022/10/22/ding-dian-ruan-jian-yi-mian-liang-jing/"/>
      <url>/2022/10/22/ding-dian-ruan-jian-yi-mian-liang-jing/</url>
      
        <content type="html"><![CDATA[<h1 id="顶点软件一面凉经"><a href="#顶点软件一面凉经" class="headerlink" title="顶点软件一面凉经"></a><center>顶点软件一面凉经</center></h1><p>9.14投递简历并笔试–&gt;9.22面试</p><p>面试前HR打电话先进行基础了解（有没有offer，考不考公/研，锐捷和顶点同样待遇下选择哪个…），发成绩单等等，挂科或者绩点太低直接挂。  </p><p>正式面试：一个技术人员，一个HR</p><p>先HR问：</p><p>1、自我介绍</p><p>2、实习是校招实习还是老师推荐？实习的一个整体感受如何？离职了吗？还要去应聘他们公司？有转正机会吗？</p><p>3、学校还有课？没有想说考公或考研吗？为什么？家人支持吗？学习成绩挺好的为什么不继续读研呢？</p><p>4、讲一下最近印象比较深刻的一个项目？我讲的是实习的项目，一个修改Maven项目版本号的后台管理系统。  </p><p>接下来给技术人员爆杀，也怪自己没准备好：</p><p>5、这个项目是web的系统还是工具？能介绍一下若依吗？</p><p>6、实习项目改版本号时会有出现什么错误吗？什么原因出现的情况？后来如何处理？说实话没印象有什么大的bug，当时一下就不知道怎么说了，答得很差。</p><p>7、这个项目明明只需要properties属性统一管理一下就行，为什么要开发一个后台管理系统？这个纯属他没认真听我对系统的介绍，或者我介绍得不够清除。</p><p>8、看你有一个商城项目，你能对这个项目的需求以及设计做一个总体介绍吗？该死的谷粒商城我其实还没吃透，大减分。</p><p>9、对秒杀功能的机制以及相应的解决方案做一个相应的描述？</p><p>10、信号量和消息队列Rabbitmq的使用哪个在前哪个在后？既然用了信号量隔绝了一部分流量，为什么还要用队列来削峰？这两个的作用好像一样？</p><p>11、有考虑过rabbitmq的某一个消费者出现故障如何处理吗？</p><p>12、有几个消费者消费秒杀的申请？两个的话是否会存在消息无序的状态？如何确保消息有序消费？那如果只用一个消费者行不行？我项目应该是只有一个的，但是当时答了两个，然后就错漏百出的回答了，感觉这里直接给面试官一个完全不会消息队列的印象。</p><p>13、消息消费失败一直重新入队，重新消费，但每次都失败，会不会彻底堵住了整个业务流程？如何解决？</p><p>14、锁库存的如何做的？库存表和记录锁库存的表是怎么设计的？放在两个消费者的情况下出现的问题是什么？怎么解决的？</p><p>15、除了这个秒杀还有哪些比较难的部分？我答了最难就是秒杀，但是有遇到几个问题，远程调用和异步调用丢失请求头问题。问丢失了哪些请求头？😓异步线程池丢失的请求头如何处理的？那线程的数据没有清理掉，后面的请求进来复用了这个线程的数据，出现数据偏差有没有考虑过？没有。😓</p><p>16、商城数据在ES上的存储结构是什么样子的？检索基于哪些字段？字段上做了哪些优化？</p><p>17、Java垃圾回收器类型以及相应区别？只记得G1，问G1的垃圾回收原理？  </p><p>又换HR来问</p><p>18、平时时间如何分配？又担任什么职务？怎么安排任务？</p><p>19、后面11月可以出来实习吗？</p><p>20、毕业设计怎么安排？做哪个方向？</p><p>21、什么时候开始投简历？投哪些公司？都是福州？</p><p>22、父母对你工作有什么想法吗？</p><p>23、福州和厦门分别期望薪资待遇？</p><p>24、未来工作规划？</p><p>25、对于出差的看法？</p><p>26、对于加班如何看待？</p><p>27、学习过程中有强度比较大的时候吗？怎么放松的？</p><p>28、宿舍几个人，宿舍活动是什么？为啥问这个，疑惑。</p><p>29、其他人也在找工作吗，有想说到同一家公司还是各找各的？问这个干啥，无聊。</p><p>30、有女朋友吗？</p><p>31、反问。</p><p>（面试几轮？1-2轮。</p><p>强制毕业前实习？不强制。</p><p>公司技术栈？比较先进）</p>]]></content>
      
      
      <categories>
          
          <category> Job Interview </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Job Interview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue几点知识点</title>
      <link href="/2022/05/28/vue-ji-dian-zhi-shi-dian/"/>
      <url>/2022/05/28/vue-ji-dian-zhi-shi-dian/</url>
      
        <content type="html"><![CDATA[<p><a href="https://note.youdao.com/s/F5YjrsTC">https://note.youdao.com/s/F5YjrsTC</a></p><p>点击上方链接查看我的有道云笔记分享！</p>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逆序对的数量（归并排序的应用）</title>
      <link href="/2021/07/11/ni-xu-dui-de-shu-liang-gui-bing-pai-xu-de-ying-yong/"/>
      <url>/2021/07/11/ni-xu-dui-de-shu-liang-gui-bing-pai-xu-de-ying-yong/</url>
      
        <content type="html"><![CDATA[<h1 id="逆序对的数量（归并排序的应用）"><a href="#逆序对的数量（归并排序的应用）" class="headerlink" title="逆序对的数量（归并排序的应用）"></a><center>逆序对的数量（归并排序的应用）</center></h1><p>原题链接<a href="https://www.acwing.com/problem/content/790/">788. 逆序对的数量 - AcWing题库</a></p><p><img src="..%5Cimages%5Cimage-20210712000257663.png" alt="image-20210712000257663"></p><p>模板：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;using namespace std;const int N &#x3D; 1e5 + 10;int q[N],tmp[N];typedef long long ll;ll merge_sort (int q[], int l, int r)&#123;    if (l &gt;&#x3D; r) return 0;    int mid &#x3D; l + r &gt;&gt; 1;    ll ans &#x3D; merge_sort(q, l, mid) + merge_sort(q, mid + 1, r);    int k &#x3D; 0, i &#x3D; l, j &#x3D; mid + 1;    while (i &lt;&#x3D; mid &amp;&amp; j &lt;&#x3D; r)    &#123;        if (q[i] &lt;&#x3D; q[j]) tmp[k ++ ] &#x3D; q[i ++ ];        else         &#123;            tmp[k ++ ] &#x3D; q[j ++ ];            ans +&#x3D; mid - i + 1;        &#125;    &#125;    while (i &lt;&#x3D; mid) tmp[k ++ ] &#x3D; q[i ++ ];    while (j &lt;&#x3D; r) tmp[k ++ ] &#x3D; q[j ++ ];        for (int i &#x3D; l, j &#x3D; 0; i &lt;&#x3D; r; i ++, j ++ ) q[i] &#x3D; tmp[j];        return ans;&#125;int main()&#123;    int n;    scanf(&quot;%d&quot;, &amp;n);    for (int i &#x3D; 0; i &lt; n; i ++ ) scanf(&quot;%d&quot;, &amp;q[i]);    cout &lt;&lt; merge_sort(q, 0, n - 1) &lt;&lt; endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>归并排序</title>
      <link href="/2021/07/11/gui-bing-pai-xu/"/>
      <url>/2021/07/11/gui-bing-pai-xu/</url>
      
        <content type="html"><![CDATA[<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a><center>归并排序</center></h1><p>原题链接</p><p>归并排序是稳定的<br>排序的稳定：指排序后两个相同值的顺序不会变<br>没有实际用途，但会考</p><p><img src="..%5Cimages%5Cimage-20210711222003318.png" alt="image-20210711222003318"></p><p>模板：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;const int N &#x3D; 1e6 + 10;int a[N], tmp[N];void merge_sort(int q[], int l, int r)&#123;    if (l &gt;&#x3D; r) return;    int mid &#x3D; l + r &gt;&gt; 1;    merge_sort(q, l, mid), merge_sort(q, mid + 1, r);    int k &#x3D; 0, i &#x3D; l, j &#x3D; mid + 1;    while (i &lt;&#x3D; mid &amp;&amp; j &lt;&#x3D; r)        if (q[i] &lt;&#x3D; q[j]) tmp[k ++ ] &#x3D; q[i ++ ];        else tmp[k ++ ] &#x3D; q[j ++ ];    while (i &lt;&#x3D; mid) tmp[k ++ ] &#x3D; q[i ++ ];    while (j &lt;&#x3D; r) tmp[k ++ ] &#x3D; q[j ++ ];    for (i &#x3D; l, j &#x3D; 0; i &lt;&#x3D; r; i ++, j ++ ) q[i] &#x3D; tmp[j];&#125;int main()&#123;    int n;    scanf(&quot;%d&quot;, &amp;n);    for (int i &#x3D; 0; i &lt; n; i ++ ) scanf(&quot;%d&quot;, &amp;a[i]);    merge_sort(a, 0, n - 1);    for (int i &#x3D; 0; i &lt; n; i ++ ) printf(&quot;%d &quot;, a[i]);    return 0;&#125;作者：yxc链接：https:&#x2F;&#x2F;www.acwing.com&#x2F;activity&#x2F;content&#x2F;code&#x2F;content&#x2F;39790&#x2F;来源：AcWing著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第k个数（快速选择算法）</title>
      <link href="/2021/07/11/di-k-ge-shu-kuai-su-xuan-ze-suan-fa/"/>
      <url>/2021/07/11/di-k-ge-shu-kuai-su-xuan-ze-suan-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="第k个数（快速选择算法）"><a href="#第k个数（快速选择算法）" class="headerlink" title="第k个数（快速选择算法）"></a><center>第k个数（快速选择算法）</center></h1><p>原题链接<a href="https://www.acwing.com/problem/content/description/788/">786. 第k个数 - AcWing题库</a></p><p>另一种思路<a href="https://www.acwing.com/solution/acwing/content/4502/">AcWing 786. 写一个和yxc大佬不同但差不多思想的方法，代码更简单 - AcWing</a></p><p>模板（快速排序的应用）：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;using namespace std;const int N &#x3D; 100010;int q[N];int quick_sort(int l, int r, int k)&#123;    if(l &#x3D;&#x3D; r) return q[l];    int i &#x3D; l - 1, j &#x3D; r + 1, x &#x3D; q[l + r &gt;&gt; 1];    while (i &lt; j)    &#123;        do i ++; while (q[i] &lt; x);        do j --; while (q[j] &gt; x);        if (i &lt; j) swap(q[i], q[j]);    &#125;    int sl &#x3D; j - l + 1;    if(k &lt;&#x3D; sl) return quick_sort(l, j, k);    else return quick_sort(j + 1, r, k - sl);&#125;int main()&#123;    int n,k;    scanf(&quot;%d%d&quot;, &amp;n, &amp;k);    for(int i &#x3D; 0; i &lt; n; i ++) scanf(&quot;%d&quot;, &amp;q[i]);    printf(&quot;%d&quot;, quick_sort(0, n - 1, k));    &#x2F;&#x2F;cout &lt;&lt; quick_sort(0, n - 1, k) &lt;&lt; endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> STL解法：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;const int N&#x3D;1000000 +1000;int a[N],n,m,i,j,k;int main()&#123;    ios::sync_with_stdio(false);    cin&gt;&gt;n&gt;&gt;m;    for(int i&#x3D;1;i&lt;&#x3D;n;i++)        cin&gt;&gt;a[i];    sort(a+1,a+1+n);    cout&lt;&lt;a[m];&#x2F;&#x2F;排序快乐    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速排序</title>
      <link href="/2021/07/11/kuai-su-pai-xu/"/>
      <url>/2021/07/11/kuai-su-pai-xu/</url>
      
        <content type="html"><![CDATA[<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a><center>快速排序</center></h1><p>原题链接<a href="https://www.acwing.com/problem/content/787/">785. 快速排序 - AcWing题库</a></p><p>题解链接<a href="https://www.acwing.com/solution/content/2096/">AcWing 785. 快速排序 - AcWing</a></p><p>视频题解链接<a href="https://www.acwing.com/video/227/">AcWing 785. 快速排序 - AcWing</a></p><p>各类排序对比：</p><p><img src="..%5Cimages%5Cimage-20210711214016030.png" alt="image-20210711214016030"></p><p>ios::sync_with_stdio(false);<br>该语句可以使得cin输入速度相比scanf差不多，一般大多数情况下scanf快</p><p>模板如下：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;const int N &#x3D; 1000010;int q[N];void quick_sort(int q[], int l, int r)&#123;    if (l &gt;&#x3D; r) return;    int i &#x3D; l - 1, j &#x3D; r + 1, x &#x3D; q[l + r &gt;&gt; 1];    while (i &lt; j)    &#123;        do i ++ ; while (q[i] &lt; x);        do j -- ; while (q[j] &gt; x);        if (i &lt; j) swap(q[i], q[j]);    &#125;    quick_sort(q, l, j);    quick_sort(q, j + 1, r);&#125;int main()&#123;    int n;    scanf(&quot;%d&quot;, &amp;n);    for (int i &#x3D; 0; i &lt; n; i ++ ) scanf(&quot;%d&quot;, &amp;q[i]);    quick_sort(q, 0, n - 1);    for (int i &#x3D; 0; i &lt; n; i ++ ) printf(&quot;%d &quot;, q[i]);    return 0;&#125;作者：yxc链接：https:&#x2F;&#x2F;www.acwing.com&#x2F;activity&#x2F;content&#x2F;code&#x2F;content&#x2F;39784&#x2F;来源：AcWing著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>C++STL快速算法：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;const int N&#x3D;1000000+100;int a[N],n,m,i,j;int main()&#x2F;&#x2F;C++ Stl使人快乐&#123;    ios::sync_with_stdio(false);&#x2F;&#x2F;使cin能在多数情况下速度                                &#x2F;&#x2F;和scanf相比差不多    &#x2F;&#x2F;最好用scanf，在c++中是最快的    cin&gt;&gt;n;    for(int i&#x3D;1;i&lt;&#x3D;n;i++)        cin&gt;&gt;a[i];    sort(a+1,a+1+n);    for(int i&#x3D;1;i&lt;&#x3D;n;i++)        cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;;    cout&lt;&lt;endl;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo注意事项和常用命令</title>
      <link href="/2021/05/03/hexo-zhu-yi-shi-xiang-he-chang-yong-ming-ling/"/>
      <url>/2021/05/03/hexo-zhu-yi-shi-xiang-he-chang-yong-ming-ling/</url>
      
        <content type="html"><![CDATA[<h1 id="hexo注意事项和常用命令"><a href="#hexo注意事项和常用命令" class="headerlink" title="hexo注意事项和常用命令"></a>hexo注意事项和常用命令</h1><p><strong>我的博客网站：</strong></p><p>Gitee：<a href="http://yizhangqing.gitee.io/">一丈青 (gitee.io)</a></p><p>GitHub：<a href="https://1zhangqing.github.io/">一丈青 (1zhangqing.github.io)</a></p><ol><li><p>自己手写front-matter块出来的方法：写—（三个减号符号-）然后回车就能出现写front-matter的块来，里面可以配置参数如下：</p><table><thead><tr><th align="center">参数</th><th align="center">描述</th><th align="center">默认值</th></tr></thead><tbody><tr><td align="center"><code>layout</code></td><td align="center">布局</td><td align="center"><a href="https://hexo.io/zh-cn/docs/configuration#%E6%96%87%E7%AB%A0"><code>config.default_layout</code></a></td></tr><tr><td align="center"><code>title</code></td><td align="center">标题</td><td align="center">文章的文件名</td></tr><tr><td align="center"><code>date</code></td><td align="center">建立日期</td><td align="center">文件建立日期</td></tr><tr><td align="center"><code>updated</code></td><td align="center">更新日期</td><td align="center">文件更新日期</td></tr><tr><td align="center"><code>comments</code></td><td align="center">开启文章的评论功能</td><td align="center">true</td></tr><tr><td align="center"><code>tags</code></td><td align="center">标签（不适用于分页）</td><td align="center"></td></tr><tr><td align="center"><code>categories</code></td><td align="center">分类（不适用于分页）</td><td align="center"></td></tr><tr><td align="center"><code>permalink</code></td><td align="center">覆盖文章网址</td><td align="center"></td></tr><tr><td align="center"><code>excerpt</code></td><td align="center">Page excerpt in plain text. Use <a href="https://hexo.io/docs/tag-plugins#Post-Excerpt">this plugin</a> to format the text</td><td align="center"></td></tr><tr><td align="center"><code>disableNunjucks</code></td><td align="center">Disable rendering of Nunjucks tag <code>&#123;&#123; &#125;&#125;</code>/<code>&#123;% %&#125;</code> and <a href="https://hexo.io/docs/tag-plugins">tag plugins</a> when enabled</td><td align="center"></td></tr><tr><td align="center"><code>lang</code></td><td align="center">Set the language to override <a href="https://hexo.io/docs/internationalization#Path">auto-detection</a></td><td align="center">Inherited from <code>_config.yml</code></td></tr></tbody></table></li><li><p>初始化一个博客系统：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">hexo init [folder]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>新建一篇文章：在BLOG文件下下git bush或者在BLOG/suorce/_post文件夹下git bush后输入该命令</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">hexo new [layout] &lt;title&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>生成静态页面</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可简写为</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">hexo g<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>新建草稿(草稿不会发表，会存储在source/_drafts文件下)</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">hexo new draft 草稿文件名<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>发表草稿</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">hexo publish 草稿文件名<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>启动服务器</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可简写为</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">hexo s<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>部署网站（上传到Gitee和Github或者自己的服务器上）</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可简写为</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">hexo d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>清除缓存文件 (<code>db.json</code>) 和已生成的静态文件 (<code>public</code>)。</p><p>在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">hexo clean<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>显示 <code>source/_drafts</code> 文件夹中的草稿文章</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">hexo --draft<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p><strong>写一篇博客并上传的步骤流程</strong><br>在BLOG文件目录下git bush here后输入hexo new [layout] filename 新建一篇博客<br>在博客中用markdown语法写完博客后<br>在BLOG文件目录下git bush here<br>在命令终端hexo clean清除缓存，然后hexo g生成静态页面，然后hexo s启动本地服务器在本地预览结果（可省略），最后hexo d部署<br>在BLOG文件夹下的_config.yml中可以查看或者配置部署地址<br>其中gitee的部署后还要再到gitee仓库里手动部署网站，GitHub则不用</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">这是直接生成静态页面并上传的简化命令：hexo g -d这是多命令一起执行的操作：hexo clean &amp;&amp; hexo g &amp;&amp; hexo shexo clean &amp;&amp; hexo g &amp;&amp; hexo d<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>上传到Gitee或者GitHub上时在_config.yml里面改deploy参数，如下图：<img src="/2021/05/03/hexo-zhu-yi-shi-xiang-he-chang-yong-ming-ling/image-20220528000432374.png" class="" title="相关配置图片"></p><p>上传后要Gitee还要手动使用Gitee Page部署一下页面，Github不用</p><blockquote><p><strong>1、Git Bash控制台配置</strong> </p><p><em>Gitee的hexo部署配置：</em></p><p>git config –global user.name “yizhangqing”</p><p>git config –global user.email “<a href="mailto:&#54;&#49;&#48;&#x31;&#49;&#x35;&#57;&#51;&#52;&#x40;&#113;&#113;&#x2e;&#x63;&#x6f;&#109;">&#54;&#49;&#48;&#x31;&#49;&#x35;&#57;&#51;&#52;&#x40;&#113;&#113;&#x2e;&#x63;&#x6f;&#109;</a>“</p><p><em>GitHub的hexo部署配置:</em></p><p>git config –global user.name “1zhangqing”</p><p>git config –global user.email “<a href="mailto:&#x36;&#49;&#x30;&#49;&#49;&#x35;&#x39;&#51;&#52;&#x40;&#x71;&#113;&#46;&#99;&#x6f;&#x6d;">&#x36;&#49;&#x30;&#49;&#49;&#x35;&#x39;&#51;&#52;&#x40;&#x71;&#113;&#46;&#99;&#x6f;&#x6d;</a>“</p><p><strong>2、修改_config.yml文件如上图位置</strong></p><p>_config.yml中部署GitHub时就注释gitee开启github，部署Gitee就注释github开启gitee</p><p><strong>3、如果密钥配置不对还要重新生成密钥</strong></p><p>ssh-keygen -t rsa -C “<a href="mailto:&#x36;&#49;&#x30;&#x31;&#x31;&#53;&#x39;&#x33;&#x34;&#x40;&#x71;&#113;&#46;&#99;&#111;&#109;">&#x36;&#49;&#x30;&#x31;&#x31;&#53;&#x39;&#x33;&#x34;&#x40;&#x71;&#113;&#46;&#99;&#111;&#109;</a>“</p><p>记得问是否overwrite重写的时候要输入y或yes，直接回车无法生成的</p><p>然后将C:\Users\一丈青.ssh\id_rsa.pub中的内容复制一下，添加到GitHub或Gitee的SSH key那里</p><p><strong>4、hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</strong></p></blockquote></li><li><p>博客中引用图片格式参考：<a href="https://hexo.io/zh-cn/docs/asset-folders">资源文件夹 | Hexo</a></p><p>现在只能在_post文件夹下新建一个和博客文章同名的文件夹，将图片放到该文件夹下，再通过如下方式引用图片：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">&#123;% asset_img example.jpg This is an example image %&#125;#说明：#asset_img标识的是使用的插件#example.jpg是文章同名文件夹下的图片名#This is an example image这部分是图片下方的注释说明<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>忘记命令一个快捷的方式就是在终端直接输入hexo后按回车，它会提示你常用命令。</p></li><li><p>博客多平台部署参考：<a href="https://gitee.com/help/articles/4136#article-header0">https://gitee.com/help/articles/4136#article-header0</a></p></li><li><p>hexo操作官方文档<a href="https://hexo.io/zh-cn/docs/">文档 | Hexo</a></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown语法注意事项</title>
      <link href="/2021/05/03/markdown-yu-fa-zhu-yi-shi-xiang/"/>
      <url>/2021/05/03/markdown-yu-fa-zhu-yi-shi-xiang/</url>
      
        <content type="html"><![CDATA[<h1 id="Markdown语法注意事项"><a href="#Markdown语法注意事项" class="headerlink" title="Markdown语法注意事项"></a><center>Markdown语法注意事项</center></h1><ol><li><p>使用#来搞标题记得要有空格即     # markdown语法注意事项<br>如果要居中之后再加粗使用标题的话就在&lt;center&gt;前加#并空格<br>一个#是一级标题，两个是二级标题，依此类推。</p></li><li><p>-+空格+[]+空格+文字 （注：注意用空格隔开）<br>可以写出代办任务  </p><ul><li><input disabled="" type="checkbox"> </li></ul></li><li><p>-+空格+[x]+空格+文字<br>可以写出已办事项  </p><ul><li><input checked="" disabled="" type="checkbox"> </li></ul></li><li><p>+ 、- 、* 创建无序列，任意数字开始+空格创建有序列表。在创建有序列表的时候，输入创建的操作就是先输入“序号.”在后面加上空格，如“1. ”这样就可以得到有序列表的第一行了。</p></li><li><blockquote><p>与天奋斗，其乐无穷！与地奋斗，其乐无穷！与人奋斗，其乐无穷！</p><p>——《毛泽东选集》之《奋斗自勉》</p></blockquote><p>上诉即为引用，引用格式为&gt;+空格</p></li><li><p><strong>空格：</strong>在输入连续的空格后，Typora 会在编辑器视图里为你保留这些空格，但当你打印或导出时，这些空格会被省略成一个。 你可以在源代码模式下，为每个空格前加一个 <code>\</code> 转义符，或者直接使用 HTML 风格的 <code>&amp;nbps;</code> 来保持连续的空格。</p></li><li><p><strong>软换行：</strong>需要说明的是，在 Markdown 语法中，换行（line break）与换段是不同的。且换行分为软换行和硬换行。在 Typora 中，你可以通过 <code>Shift + Enter</code> 完成一次软换行。软换行只在编辑界面可见，当文档被导出时换行会被省略。</p></li><li><p><strong>硬换行：</strong>你可以通过 <code>空格 + 空格 + Shift + Enter</code> 完成一次硬换行，而这也是许多 Markdown 编辑器所原生支持的。硬换行在文档被导出时将被保留，且没有换段的段后距。</p></li><li><p><strong>换段：</strong>你可以通过 <code>Enter</code> 完成一次换段。Typora 会自动帮你完成两次 <code>Shift + Enter</code> 的软换行，从而完成一次换段。这也意味着在 Markdown 语法下，换段是通过在段与段之间加入空行来实现的。</p></li><li><p><strong>Typora 中代码的插入也可以分为行内和块间两种：</strong></p></li><li><p><strong>行内代码：</strong>用 <code>...</code> 或 <code>...</code> 括起代码，代码会以主题中设置的样式出现在行内，但不会实现代码高亮。</p></li><li><p><strong>代码块：</strong>输入 ```后并输入语言名，换行，开始写代码，Typora 就会自动帮你实现代码高亮。Typora 原生支持许多编程语言代码块的语法高亮，基本日常常用的编程语言它都能很好地支持。 除此以外，你也可以直接换行开始写，而后再选择语言。</p></li><li><p><strong>「打字机模式」</strong>使得所编辑的那一行永远处于屏幕正中。</p></li><li><p><strong>「专注模式」</strong>正在编辑的那一行保留颜色，而其他行的字体呈灰色。</p></li><li><p>Typora 的图片插入功能是广受好评的。要知道，Markdown 原生不太注重图片插入的功能，但你可以在 Typora 中：</p><ul><li><p>直接使用 <code>右键 - 复制 Ctrl + V</code> 将网络图片、剪贴板图片复制到文档中</p></li><li><p>拖动本地图片到文档中</p><p> Typora 会自动帮你插入符合 Markdown 语法的图片语句，并给它加上标题。</p><p> 更强大的是，Typora 支持在拖动或 <code>Ctrl + V</code> 网络图片后自动将其保存到本地。你可以在 <code>文件 - 偏好设置 - 编辑器 - 图片插入</code> 中选择复制到哪个路径，什么情况下需要复制。</p></li></ul></li><li><h5 id="上下标与注释"><a href="#上下标与注释" class="headerlink" title="上下标与注释"></a><strong>上下标与注释</strong></h5><ul><li>上标的另外一种写法是<code>文本^上标^</code> 例如：y^2^ 的写法是<code>y^2^</code></li><li>下标语法是使用<code>~</code>包裹，例如：H<del>2</del> 的写法就是<code>H~2~</code></li></ul></li></ol><pre class="line-numbers language-python" data-language="python"><code class="language-python">#这是代码块注释这不是代码块注释<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol start="17"><li>直接在Typora中右键则可插入代码块，有序无序序列，链接，代办未办事项等等。</li></ol><!--这是非代码块的注释--><!--zheshizhushi--><ol start="18"><li>在 Typora 中，用 <code>:emoji:</code> 的形式来打出 emoji，软件会自动给出图形的提示。(下附Typora中的emoji表情大全链接)<br>可以通过使用<code>ESC</code>键触发表情建议补全功能，也可在功能面板启用后自动触发此功能。同时，直接从菜单栏<code>Edit</code> -&gt; <code>Emoji &amp; Symbols</code>插入UTF8表情符号(快捷键win+。句号)<br>或者使用下面的方法<br>访问网站 <a href="https://emojikeyboard.org/%EF%BC%8C%E6%89%BE%E5%88%B0%E9%9C%80%E8%A6%81%E7%9A%84%E7%AC%A6%E5%8F%B7%EF%BC%8C%E9%BC%A0%E6%A0%87%E5%B7%A6%E9%94%AE%E5%8D%95%E5%87%BB%EF%BC%8C%E7%84%B6%E5%90%8E%E7%B2%98%E8%B4%B4%E5%88%B0%E9%9C%80%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9%E5%B0%B1%E8%A1%8C%E4%BA%86%EF%BC%81:ok_hand">https://emojikeyboard.org/，找到需要的符号，鼠标左键单击，然后粘贴到需要的地方就行了！:ok_hand</a>:</li></ol><p>本文参考:</p><p><a href="https://www.jianshu.com/p/ebe52d2d468f">Markdown语法大全(超级版) - 简书 (jianshu.com)</a><br><a href="https://www.cnblogs.com/hyz-it/p/13662304.html">Typora常用功能使用详解 - Learning-没death - 博客园 (cnblogs.com)</a><br><a href="https://blog.csdn.net/mollen/article/details/84110708">TYPORA语法大全_mollen的博客-CSDN博客_typora语法</a><br><a href="https://blog.csdn.net/mingzhuo_126/article/details/82722455">使用Typora添加数学公式_姚明明的博客-CSDN博客_typora数学公式</a><br><a href="https://blog.csdn.net/weixin_42395140/article/details/111642339">(1条消息) Typora中的emoji表情_江蓠-的博客-CSDN博客_typora表情</a></p>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSDN自带markdown编辑器</title>
      <link href="/2021/05/03/csdn-zi-dai-markdown-bian-ji-qi/"/>
      <url>/2021/05/03/csdn-zi-dai-markdown-bian-ji-qi/</url>
      
        <content type="html"><![CDATA[<p>@<a href="%E8%BF%99%E9%87%8C%E5%86%99%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9B%AE%E5%BD%95%E6%A0%87%E9%A2%98">TOC</a></p><h1 id="欢迎使用Markdown编辑器"><a href="#欢迎使用Markdown编辑器" class="headerlink" title="欢迎使用Markdown编辑器"></a>欢迎使用Markdown编辑器</h1><p>你好！ 这是你第一次使用 <strong>Markdown编辑器</strong> 所展示的欢迎页。如果你想学习如何使用Markdown编辑器, 可以仔细阅读这篇文章，了解一下Markdown的基本语法知识。</p><h2 id="新的改变"><a href="#新的改变" class="headerlink" title="新的改变"></a>新的改变</h2><p>我们对Markdown编辑器进行了一些功能拓展与语法支持，除了标准的Markdown编辑器功能，我们增加了如下几点新功能，帮助你用它写博客：</p><ol><li><strong>全新的界面设计</strong> ，将会带来全新的写作体验；</li><li>在创作中心设置你喜爱的代码高亮样式，Markdown <strong>将代码片显示选择的高亮样式</strong> 进行展示；</li><li>增加了 <strong>图片拖拽</strong> 功能，你可以将本地的图片直接拖拽到编辑区域直接展示；</li><li>全新的 <strong>KaTeX数学公式</strong> 语法；</li><li>增加了支持<strong>甘特图的mermaid语法<a href="%5Bmermaid%E8%AF%AD%E6%B3%95%E8%AF%B4%E6%98%8E%5D(https://mermaidjs.github.io/)">^1</a></strong> 功能；</li><li>增加了 <strong>多屏幕编辑</strong> Markdown文章功能；</li><li>增加了 <strong>焦点写作模式、预览模式、简洁写作模式、左右区域同步滚轮设置</strong> 等功能，功能按钮位于编辑区域与预览区域中间；</li><li>增加了 <strong>检查列表</strong> 功能。</li></ol><h2 id="功能快捷键"><a href="#功能快捷键" class="headerlink" title="功能快捷键"></a>功能快捷键</h2><p>撤销：<kbd>Ctrl/Command</kbd> + <kbd>Z</kbd><br>重做：<kbd>Ctrl/Command</kbd> + <kbd>Y</kbd><br>加粗：<kbd>Ctrl/Command</kbd> + <kbd>B</kbd><br>斜体：<kbd>Ctrl/Command</kbd> + <kbd>I</kbd><br>标题：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>H</kbd><br>无序列表：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>U</kbd><br>有序列表：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>O</kbd><br>检查列表：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>C</kbd><br>插入代码：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>K</kbd><br>插入链接：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>L</kbd><br>插入图片：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>G</kbd><br>查找：<kbd>Ctrl/Command</kbd> + <kbd>F</kbd><br>替换：<kbd>Ctrl/Command</kbd> + <kbd>G</kbd></p><h2 id="合理的创建标题，有助于目录的生成"><a href="#合理的创建标题，有助于目录的生成" class="headerlink" title="合理的创建标题，有助于目录的生成"></a>合理的创建标题，有助于目录的生成</h2><p>直接输入1次<kbd>#</kbd>，并按下<kbd>space</kbd>后，将生成1级标题。<br>输入2次<kbd>#</kbd>，并按下<kbd>space</kbd>后，将生成2级标题。<br>以此类推，我们支持6级标题。有助于使用<code>TOC</code>语法后生成一个完美的目录。</p><h2 id="如何改变文本的样式"><a href="#如何改变文本的样式" class="headerlink" title="如何改变文本的样式"></a>如何改变文本的样式</h2><p><em>强调文本</em> <em>强调文本</em></p><p><strong>加粗文本</strong> <strong>加粗文本</strong></p><p>==标记文本==</p><p><del>删除文本</del></p><blockquote><p>引用文本</p></blockquote><p>H<del>2</del>O is是液体。</p><p>2^10^ 运算结果是 1024.</p><h2 id="插入链接与图片"><a href="#插入链接与图片" class="headerlink" title="插入链接与图片"></a>插入链接与图片</h2><p>链接: <a href="https://www.csdn.net/">link</a>.</p><p>图片: <img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hdmF0YXIuY3Nkbi5uZXQvNy83L0IvMV9yYWxmX2h4MTYzY29tLmpwZw" alt="Alt"></p><p>带尺寸的图片: ![Alt](<a href="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hdmF0YXIuY3Nkbi5uZXQvNy83L0IvMV9yYWxmX2h4MTYzY29tLmpwZw">https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hdmF0YXIuY3Nkbi5uZXQvNy83L0IvMV9yYWxmX2h4MTYzY29tLmpwZw</a> =30x30)</p><p>居中的图片: <img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hdmF0YXIuY3Nkbi5uZXQvNy83L0IvMV9yYWxmX2h4MTYzY29tLmpwZw#pic_center" alt="Alt"></p><p>居中并且带尺寸的图片: ![Alt](<a href="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hdmF0YXIuY3Nkbi5uZXQvNy83L0IvMV9yYWxmX2h4MTYzY29tLmpwZw#pic_center">https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hdmF0YXIuY3Nkbi5uZXQvNy83L0IvMV9yYWxmX2h4MTYzY29tLmpwZw#pic_center</a> =30x30)</p><p>当然，我们为了让用户更加便捷，我们增加了图片拖拽功能。</p><h2 id="如何插入一段漂亮的代码片"><a href="#如何插入一段漂亮的代码片" class="headerlink" title="如何插入一段漂亮的代码片"></a>如何插入一段漂亮的代码片</h2><p>去<a href="https://mp.csdn.net/console/configBlog">博客设置</a>页面，选择一款你喜欢的代码片高亮样式，下面展示同样高亮的 <code>代码片</code>.</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// An highlighted block</span><span class="token keyword">var</span> foo <span class="token operator">=</span> <span class="token string">'bar'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="生成一个适合你的列表"><a href="#生成一个适合你的列表" class="headerlink" title="生成一个适合你的列表"></a>生成一个适合你的列表</h2><ul><li>项目<ul><li>项目<ul><li>项目</li></ul></li></ul></li></ul><ol><li>项目1</li><li>项目2</li><li>项目3</li></ol><ul><li><input disabled="" type="checkbox"> 计划任务</li><li><input checked="" disabled="" type="checkbox"> 完成任务</li></ul><h2 id="创建一个表格"><a href="#创建一个表格" class="headerlink" title="创建一个表格"></a>创建一个表格</h2><p>一个简单的表格是这么创建的：<br>| 项目 | Value |<br>| —- | —– |<br>| 电脑 | $1600 |<br>| 手机 | $12   |<br>| 导管 | $1    |</p><h3 id="设定内容居中、居左、居右"><a href="#设定内容居中、居左、居右" class="headerlink" title="设定内容居中、居左、居右"></a>设定内容居中、居左、居右</h3><p>使用<code>:---------:</code>居中<br>使用<code>:----------</code>居左<br>使用<code>----------:</code>居右<br>|     第一列     |         第二列 | 第三列         |<br>| :————: | ————-: | :————- |<br>| 第一列文本居中 | 第二列文本居右 | 第三列文本居左 |</p><h3 id="SmartyPants"><a href="#SmartyPants" class="headerlink" title="SmartyPants"></a>SmartyPants</h3><p>SmartyPants将ASCII标点字符转换为“智能”印刷标点HTML实体。例如：<br>|    TYPE   |ASCII                          |HTML<br>|—————-|——————————-|—————————–|<br>|Single backticks|<code>&#39;Isn&#39;t this fun?&#39;</code>            |’Isn’t this fun?’            |<br>|Quotes          |<code>&quot;Isn&#39;t this fun?&quot;</code>            |”Isn’t this fun?”            |<br>|Dashes          |<code>-- is en-dash, --- is em-dash</code>|– is en-dash, — is em-dash|</p><h2 id="创建一个自定义列表"><a href="#创建一个自定义列表" class="headerlink" title="创建一个自定义列表"></a>创建一个自定义列表</h2><dl><dt>Markdown</dt><dd>Text-to-HTML conversion tool</dd></dl><dl><dt>Authors<br>:  John</dt><dd>Luke</dd></dl><h2 id="如何创建一个注脚"><a href="#如何创建一个注脚" class="headerlink" title="如何创建一个注脚"></a>如何创建一个注脚</h2><p>一个具有注脚的文本。<a href="%E6%B3%A8%E8%84%9A%E7%9A%84%E8%A7%A3%E9%87%8A">^2</a></p><h2 id="注释也是必不可少的"><a href="#注释也是必不可少的" class="headerlink" title="注释也是必不可少的"></a>注释也是必不可少的</h2><p>Markdown将文本转换为 HTML。</p><p>*[HTML]:   超文本标记语言</p><h2 id="KaTeX数学公式"><a href="#KaTeX数学公式" class="headerlink" title="KaTeX数学公式"></a>KaTeX数学公式</h2><p>您可以使用渲染LaTeX数学表达式 <a href="https://khan.github.io/KaTeX/">KaTeX</a>:</p><p>Gamma公式展示 $\Gamma(n) = (n-1)!\quad\forall<br>n\in\mathbb N$ 是通过欧拉积分</p><p>$$<br>\Gamma(z) = \int_0^\infty t^{z-1}e^{-t}dt,.<br>$$</p><blockquote><p>你可以找到更多关于的信息 <strong>LaTeX</strong> 数学表达式<a href="http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference">here</a>.</p></blockquote><h2 id="新的甘特图功能，丰富你的文章"><a href="#新的甘特图功能，丰富你的文章" class="headerlink" title="新的甘特图功能，丰富你的文章"></a>新的甘特图功能，丰富你的文章</h2><pre class="line-numbers language-mermaid" data-language="mermaid"><code class="language-mermaid">gantt        dateFormat  YYYY-MM-DD        title Adding GANTT diagram functionality to mermaid        section 现有任务        已完成               :done,    des1, 2014-01-06,2014-01-08        进行中               :active,  des2, 2014-01-09, 3d        计划一               :         des3, after des2, 5d        计划二               :         des4, after des3, 5d<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>关于 <strong>甘特图</strong> 语法，参考 <a href="https://mermaidjs.github.io/">这儿</a>,</li></ul><h2 id="UML-图表"><a href="#UML-图表" class="headerlink" title="UML 图表"></a>UML 图表</h2><p>可以使用UML图表进行渲染。 <a href="https://mermaidjs.github.io/">Mermaid</a>. 例如下面产生的一个序列图：</p><pre class="line-numbers language-mermaid" data-language="mermaid"><code class="language-mermaid">sequenceDiagram张三 -&gt;&gt; 李四: 你好！李四, 最近怎么样?李四--&gt;&gt;王五: 你最近怎么样，王五？李四--x 张三: 我很好，谢谢!李四-x 王五: 我很好，谢谢!Note right of 王五: 李四想了很长时间, 文字太长了&lt;br&#x2F;&gt;不适合放在一行.李四--&gt;&gt;张三: 打量着王五...张三-&gt;&gt;王五: 很好... 王五, 你怎么样?<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这将产生一个流程图。:</p><pre class="line-numbers language-mermaid" data-language="mermaid"><code class="language-mermaid">graph LRA[长方形] -- 链接 --&gt; B((圆))A --&gt; C(圆角长方形)B --&gt; D&#123;菱形&#125;C --&gt; D<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>关于 <strong>Mermaid</strong> 语法，参考 <a href="https://mermaidjs.github.io/">这儿</a>,</li></ul><h2 id="FLowchart流程图"><a href="#FLowchart流程图" class="headerlink" title="FLowchart流程图"></a>FLowchart流程图</h2><p>我们依旧会支持flowchart的流程图：</p><pre class="line-numbers language-mermaid" data-language="mermaid"><code class="language-mermaid">flowchatst&#x3D;&gt;start: 开始e&#x3D;&gt;end: 结束op&#x3D;&gt;operation: 我的操作cond&#x3D;&gt;condition: 确认？st-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>关于 <strong>Flowchart流程图</strong> 语法，参考 <a href="http://adrai.github.io/flowchart.js/">这儿</a>.</li></ul><h2 id="导出与导入"><a href="#导出与导入" class="headerlink" title="导出与导入"></a>导出与导入</h2><h3 id="导出"><a href="#导出" class="headerlink" title="导出"></a>导出</h3><p>如果你想尝试使用此编辑器, 你可以在此篇文章任意编辑。当你完成了一篇文章的写作, 在上方工具栏找到 <strong>文章导出</strong> ，生成一个.md文件或者.html文件进行本地保存。</p><h3 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h3><p>如果你想加载一篇你写过的.md文件，在上方工具栏可以选择导入功能进行对应扩展名的文件导入，<br>继续你的创作。</p>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python基于协程的异步编程文档</title>
      <link href="/2021/05/03/python-ji-yu-xie-cheng-de-yi-bu-bian-cheng-wen-dang/"/>
      <url>/2021/05/03/python-ji-yu-xie-cheng-de-yi-bu-bian-cheng-wen-dang/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="协程-amp-异步编程-asyncio"><a href="#协程-amp-异步编程-asyncio" class="headerlink" title="协程 &amp; 异步编程(asyncio)"></a>协程 &amp; 异步编程(asyncio)</h1><p>协程不是计算机提供的，而是由程序员人为创造的。<br><strong>协程（Coroutine）</strong>,也可以被称为微线程，是一种用户态内的上下文切换技术，通俗地讲（讲人话:dog:)，协程就是通过一个线程实现代码块相互切换执行。<br>例如：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">def func1():print(1)    ...print(2)def func2():print(3)    ...print(4)func1()func2()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述代码是普通的函数定义和执行，按流程分别执行两个函数中的代码，并先后会输出：<code>1、2、3、4</code>。但如果介入协程技术那么就可以实现函数见代码切换执行，最终输入：<code>1、3、2、4</code> 。</p><h2 id="1-协程的实现"><a href="#1-协程的实现" class="headerlink" title="1. 协程的实现"></a>1. 协程的实现</h2><p>在Python中有多种方式可以实现协程，例如：</p><ul><li>greenlet，是一个第三方模块，用于实现协程代码（Gevent协程就是基于greenlet实现）</li><li>yield，生成器，借助生成器的特点也可以实现协程代码。</li><li>asyncio，在Python3.4中引入的模块用于编写协程代码。</li><li>async &amp; awiat，在Python3.5中引入的两个关键字，结合asyncio模块可以更方便的编写协程代码。</li></ul><h3 id="1-1-greenlet"><a href="#1-1-greenlet" class="headerlink" title="1.1 greenlet"></a>1.1 greenlet</h3><p>greentlet是一个第三方模块，需要提前安装 <code>pip3 install greenlet</code>才能使用。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">from greenlet import greenletdef func1():    print(1)        # 第1步：输出 1    gr2.switch()    # 第3步：切换到 func2 函数    print(2)        # 第6步：输出 2    gr2.switch()    # 第7步：切换到 func2 函数，从上一次执行的位置继续向后执行def func2():    print(3)        # 第4步：输出 3    gr1.switch()    # 第5步：切换到 func1 函数，从上一次执行的位置继续向后执行    print(4)        # 第8步：输出 4gr1 &#x3D; greenlet(func1)gr2 &#x3D; greenlet(func2)gr1.switch() # 第1步：去执行 func1 函数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：switch中也可以传递参数用于在切换执行时相互传递值。</p><h3 id="1-2-yield"><a href="#1-2-yield" class="headerlink" title="1.2 yield"></a>1.2 yield</h3><p>基于Python的生成器的yield和yield form关键字实现协程代码。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">def func1():    yield 1    yield from func2()    yield 2def func2():    yield 3    yield 4f1 &#x3D; func1()for item in f1:    print(item)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：yield form关键字是在Python3.3中引入的。</p><h3 id="1-3-asyncio"><a href="#1-3-asyncio" class="headerlink" title="1.3 asyncio"></a>1.3 asyncio</h3><p>在Python3.4之前官方未提供协程的类库，一般大家都是使用greenlet等其他来实现。在Python3.4发布后官方正式支持协程，即：asyncio模块。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import asyncio@asyncio.coroutinedef func1():    print(1)    yield from asyncio.sleep(2)  # 遇到IO耗时操作，自动化切换到tasks中的其他任务    print(2)@asyncio.coroutinedef func2():    print(3)    yield from asyncio.sleep(2) # 遇到IO耗时操作，自动化切换到tasks中的其他任务    print(4)tasks &#x3D; [    asyncio.ensure_future( func1() ),    asyncio.ensure_future( func2() )]loop &#x3D; asyncio.get_event_loop()loop.run_until_complete(asyncio.wait(tasks))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：基于asyncio模块实现的协程比之前的要更厉害，因为他的内部还集成了遇到IO耗时操作自动切花的功能。</p><h3 id="1-4-async-amp-awit"><a href="#1-4-async-amp-awit" class="headerlink" title="1.4 async &amp; awit"></a>1.4 async &amp; awit</h3><p>async &amp; awit 关键字在Python3.5版本中正式引入，基于他编写的协程代码其实就是 上一示例 的加强版，让代码可以更加简便。</p><p>Python3.8之后 <code>@asyncio.coroutine</code> 装饰器就会被移除，推荐使用async &amp; awit 关键字实现协程代码。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import asyncioasync def func1():    print(1)    await asyncio.sleep(2)    print(2)async def func2():    print(3)    await asyncio.sleep(2)    print(4)tasks &#x3D; [    asyncio.ensure_future(func1()),    asyncio.ensure_future(func2())]loop &#x3D; asyncio.get_event_loop()loop.run_until_complete(asyncio.wait(tasks))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-5-小结"><a href="#1-5-小结" class="headerlink" title="1.5 小结"></a>1.5 小结</h3><p>关于协程有多种实现方式，目前主流使用是Python官方推荐的asyncio模块和async&amp;await关键字的方式，例如：在tonado、sanic、fastapi、django3 中均已支持。</p><p>接下来，我们也会针对 <code>asyncio模块</code> + <code>async &amp; await</code> 关键字进行更加详细的讲解。</p><h2 id="2-协程的意义"><a href="#2-协程的意义" class="headerlink" title="2.协程的意义"></a>2.协程的意义</h2><p>通过学习，我们已经了解到协程可以通过一个线程在多个上下文中进行来回切换执行。</p><p><span><strong>但是</strong></span>，协程来回切换执行的意义何在呢？（网上看到很多文章舔协程，协程牛逼之处是哪里呢？）</p><pre class="line-numbers language-none"><code class="language-none">计算型的操作，利用协程来回切换执行，没有任何意义，来回切换并保存状态 反倒会降低性能。IO型的操作，利用协程在IO等待时间就去切换执行其他任务，当IO操作结束后再自动回调，那么就会大大节省资源并提供性能，从而实现异步编程（不等待任务结束就可以去执行其他代码）。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="2-1-爬虫案例"><a href="#2-1-爬虫案例" class="headerlink" title="2.1 爬虫案例"></a>2.1 爬虫案例</h3><p>例如：用代码实现下载 <code>url_list</code> 中的图片。</p><ul><li><p>方式一：同步编程实现</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">&quot;&quot;&quot;下载图片使用第三方模块requests，请提前安装：pip3 install requests&quot;&quot;&quot;import requestsdef download_image(url):print(&quot;开始下载:&quot;,url)    # 发送网络请求，下载图片    response &#x3D; requests.get(url)print(&quot;下载完成&quot;)    # 图片保存到本地文件    file_name &#x3D; url.rsplit(&#39;_&#39;)[-1]    with open(file_name, mode&#x3D;&#39;wb&#39;) as file_object:        file_object.write(response.content)if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    url_list &#x3D; [        &#39;https:&#x2F;&#x2F;www3.autoimg.cn&#x2F;newsdfs&#x2F;g26&#x2F;M02&#x2F;35&#x2F;A9&#x2F;120x90_0_autohomecar__ChsEe12AXQ6AOOH_AAFocMs8nzU621.jpg&#39;,        &#39;https:&#x2F;&#x2F;www2.autoimg.cn&#x2F;newsdfs&#x2F;g30&#x2F;M01&#x2F;3C&#x2F;E2&#x2F;120x90_0_autohomecar__ChcCSV2BBICAUntfAADjJFd6800429.jpg&#39;,        &#39;https:&#x2F;&#x2F;www3.autoimg.cn&#x2F;newsdfs&#x2F;g26&#x2F;M0B&#x2F;3C&#x2F;65&#x2F;120x90_0_autohomecar__ChcCP12BFCmAIO83AAGq7vK0sGY193.jpg&#39;    ]    for item in url_list:        download_image(item)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>方式二：基于协程的异步编程实现</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">&quot;&quot;&quot;下载图片使用第三方模块aiohttp，请提前安装：pip3 install aiohttp&quot;&quot;&quot;#!&#x2F;usr&#x2F;bin&#x2F;env python# -*- coding:utf-8 -*-import aiohttpimport asyncioasync def fetch(session, url):    print(&quot;发送请求：&quot;, url)    async with session.get(url, verify_ssl&#x3D;False) as response:        content &#x3D; await response.content.read()        file_name &#x3D; url.rsplit(&#39;_&#39;)[-1]        with open(file_name, mode&#x3D;&#39;wb&#39;) as file_object:            file_object.write(content)async def main():    async with aiohttp.ClientSession() as session:        url_list &#x3D; [            &#39;https:&#x2F;&#x2F;www3.autoimg.cn&#x2F;newsdfs&#x2F;g26&#x2F;M02&#x2F;35&#x2F;A9&#x2F;120x90_0_autohomecar__ChsEe12AXQ6AOOH_AAFocMs8nzU621.jpg&#39;,            &#39;https:&#x2F;&#x2F;www2.autoimg.cn&#x2F;newsdfs&#x2F;g30&#x2F;M01&#x2F;3C&#x2F;E2&#x2F;120x90_0_autohomecar__ChcCSV2BBICAUntfAADjJFd6800429.jpg&#39;,            &#39;https:&#x2F;&#x2F;www3.autoimg.cn&#x2F;newsdfs&#x2F;g26&#x2F;M0B&#x2F;3C&#x2F;65&#x2F;120x90_0_autohomecar__ChcCP12BFCmAIO83AAGq7vK0sGY193.jpg&#39;        ]        tasks &#x3D; [asyncio.create_task(fetch(session, url)) for url in url_list]        await asyncio.wait(tasks)if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    asyncio.run(main())<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>上述两种的执行对比之后会发现，<code>基于协程的异步编程</code> 要比 <code>同步编程</code>的效率高了很多。因为：</p><ul><li>同步编程，按照顺序逐一排队执行，如果图片下载时间为2分钟，那么全部执行完则需要6分钟。</li><li>异步编程，几乎同时发出了3个下载任务的请求（遇到IO请求自动切换去发送其他任务请求），如果图片下载时间为2分钟，那么全部执行完毕也大概需要2分钟左右就可以了。</li></ul><h3 id="2-2-小结"><a href="#2-2-小结" class="headerlink" title="2.2 小结"></a>2.2 小结</h3><p>协程一般应用在有IO操作的程序中，因为协程可以利用IO等待的时间去执行一些其他的代码，从而提升代码执行效率。</p><p>生活中不也是这样的么，假设 你是一家制造汽车的老板，员工点击设备的【开始】按钮之后，在设备前需等待30分钟，然后点击【结束】按钮，此时作为老板的你一定希望这个员工在等待的那30分钟的时间去做点其他的工作。</p><h2 id="3-异步编程"><a href="#3-异步编程" class="headerlink" title="3.异步编程"></a>3.异步编程</h2><p>基于<code>async</code> &amp; <code>await</code>关键字的协程可以实现异步编程，这也是目前python异步相关的主流技术。</p><p>想要真正的了解Python中内置的异步编程，根据下文的顺序一点点来看。</p><h3 id="3-1-事件循环"><a href="#3-1-事件循环" class="headerlink" title="3.1 事件循环"></a>3.1 事件循环</h3><p>事件循环，可以把他当做是一个while循环，这个while循环在周期性的运行并执行一些<code>任务</code>，在特定条件下终止循环。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 伪代码任务列表 &#x3D; [ 任务1, 任务2, 任务3,... ]while True:    可执行的任务列表，已完成的任务列表 &#x3D; 去任务列表中检查所有的任务，将&#39;可执行&#39;和&#39;已完成&#39;的任务返回        for 就绪任务 in 可执行的任务列表:        执行已就绪的任务            for 已完成的任务 in 已完成的任务列表:        在任务列表中移除 已完成的任务如果 任务列表 中的任务都已完成，则终止循环<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python">import asyncio# 去生成或获取一个事件循环loop &#x3D; asyncio.get_event_loop()# 将任务放到&#96;任务列表&#96;loop.run_until_complete(任务)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在编写程序时候可以通过如下代码来获取和创建事件循环。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import asyncioloop &#x3D; asyncio.get_event_loop()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="3-2-协程和异步编程"><a href="#3-2-协程和异步编程" class="headerlink" title="3.2 协程和异步编程"></a>3.2 协程和异步编程</h3><p>协程函数，定义形式为 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#async-def"><code>async def</code></a> 的函数。</p><p>协程对象，调用 <em>协程函数</em> 所返回的对象。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 定义一个协程函数async def func():    pass# 调用协程函数，返回一个协程对象result &#x3D; func()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意</strong>：调用协程函数时，函数内部代码不会执行，只是会返回一个协程对象。</p><h4 id="3-2-1-基本应用"><a href="#3-2-1-基本应用" class="headerlink" title="3.2.1 基本应用"></a>3.2.1 基本应用</h4><p>程序中，如果想要执行协程函数的内部代码，需要 <code>事件循环</code> 和 <code>协程对象</code> 配合才能实现，如：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import asyncioasync def func():    print(&quot;协程内部代码&quot;)    # 调用协程函数，返回一个协程对象。    result &#x3D; func()    # 方式一#     loop &#x3D; asyncio.get_event_loop()     # 创建一个事件循环#     loop.run_until_complete(result)     # 将协程当做任务提交到事件循环的任务列表中，协程执行完成之后终止。    # 方式二    # 本质上方式一是一样的，内部先 创建事件循环 然后执行 run_until_complete，一个简便的写法。    # asyncio.run 函数在 Python 3.7 中加入 asyncio 模块    asyncio.run(result)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个过程可以简单理解为：将<code>协程</code>当做任务添加到 <code>事件循环</code> 的任务列表，然后事件循环检测列表中的<code>协程</code>是否 已准备就绪（默认可理解为就绪状态），如果准备就绪则执行其内部代码。</p><h4 id="3-2-2-await"><a href="#3-2-2-await" class="headerlink" title="3.2.2 await"></a>3.2.2 await</h4><p>await是一个只能在协程函数中使用的关键字，用于遇到IO操作时挂起 当前协程（任务），当前协程（任务）挂起过程中 事件循环可以去执行其他的协程（任务），当前协程IO处理完成时，可以再次切换回来执行await之后的代码。代码如下：</p><p><strong>示例1：</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import asyncioasync def func():    print(&quot;执行协程函数内部代码&quot;)        # 遇到IO操作挂起当前协程（任务），等IO操作完成之后再继续往下执行。        # 当前协程挂起时，事件循环可以去执行其他协程（任务）。    response &#x3D; await asyncio.sleep(2)    print(&quot;IO请求结束，结果为：&quot;, response)    result &#x3D; func()asyncio.run(result)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例2：</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import asyncioasync def others():    print(&quot;start&quot;)    await asyncio.sleep(2)    print(&#39;end&#39;)    return &#39;返回值&#39;async def func():    print(&quot;执行协程函数内部代码&quot;)        # 遇到IO操作挂起当前协程（任务），等IO操作完成之后再继续往下执行。当前协程挂起时，事件循环可以去执行其他协程（任务）。    response &#x3D; await others()        print(&quot;IO请求结束，结果为：&quot;, response)    asyncio.run( func() )<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例3：</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import asyncioasync def others():    print(&quot;start&quot;)    await asyncio.sleep(2)    print(&#39;end&#39;)    return &#39;返回值&#39;async def func():    print(&quot;执行协程函数内部代码&quot;)        # 遇到IO操作挂起当前协程（任务），等IO操作完成之后再继续往下执行。当前协程挂起时，事件循环可以去执行其他协程（任务）。    response1 &#x3D; await others()    print(&quot;IO请求结束，结果为：&quot;, response1)          response2 &#x3D; await others()    print(&quot;IO请求结束，结果为：&quot;, response2)     asyncio.run( func() )<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述的所有示例都只是创建了一个任务，即：事件循环的任务列表中只有一个任务，所以在IO等待时无法演示切换到其他任务效果。</p><p>在程序想要创建多个任务对象，需要使用Task对象来实现。</p><h4 id="3-2-3-Task对象"><a href="#3-2-3-Task对象" class="headerlink" title="3.2.3 Task对象"></a>3.2.3 Task对象</h4><blockquote><p><em>Tasks</em> are used to schedule coroutines <em>concurrently</em>.</p><p>When a coroutine is wrapped into a <em>Task</em> with functions like <a href="https://docs.python.org/3.8/library/asyncio-task.html#asyncio.create_task"><code>asyncio.create_task()</code></a> the coroutine is automatically scheduled to run soon。</p></blockquote><p>Tasks用于并发调度协程，通过<code>asyncio.create_task(协程对象)</code>的方式创建Task对象，这样可以让协程加入事件循环中等待被调度执行。除了使用 <code>asyncio.create_task()</code> 函数以外，还可以用低层级的 <code>loop.create_task()</code> 或 <code>ensure_future()</code> 函数。不建议手动实例化 Task 对象。</p><p>本质上是将协程对象封装成task对象，并将协程立即加入事件循环，同时追踪协程的状态。</p><p>注意：<code>asyncio.create_task()</code> 函数在 Python 3.7 中被加入。在 Python 3.7 之前，可以改用低层级的 <code>asyncio.ensure_future()</code> 函数。</p><p><strong>示例1：</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import asyncioasync def func():    print(1)    await asyncio.sleep(2)    print(2)    return &quot;返回值&quot;async def main():    print(&quot;main开始&quot;)        # 创建协程，将协程封装到一个Task对象中并立即添加到事件循环的任务列表中，等待事件循环去执行（默认是就绪状态）。    task1 &#x3D; asyncio.create_task(func())   # 创建协程，将协程封装到一个Task对象中并立即添加到事件循环的任务列表中，等待事件循环去执行（默认是就绪状态）。    task2 &#x3D; asyncio.create_task(func())        print(&quot;main结束&quot;)        # 当执行某协程遇到IO操作时，会自动化切换执行其他任务。    # 此处的await是等待相对应的协程全都执行完毕并获取结果    ret1 &#x3D; await task1    ret2 &#x3D; await task2    print(ret1, ret2)asyncio.run(main())<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例2：</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import asyncioasync def func():    print(1)    await asyncio.sleep(2)    print(2)    return &quot;返回值&quot;async def main():    print(&quot;main开始&quot;)        # 创建协程，将协程封装到Task对象中并添加到事件循环的任务列表中，等待事件循环去执行（默认是就绪状态）。    # 在调用    task_list &#x3D; [                asyncio.create_task(func(), name&#x3D;&quot;n1&quot;),        asyncio.create_task(func(), name&#x3D;&quot;n2&quot;)    ]        print(&quot;main结束&quot;)    # 当执行某协程遇到IO操作时，会自动化切换执行其他任务。    # 此处的await是等待所有协程执行完毕，并将所有协程的返回值保存到done    # 如果设置了timeout值，则意味着此处最多等待的秒，完成的协程返回值写入到done中，未完成则写到pending中。    done, pending &#x3D; await asyncio.wait(task_list, timeout&#x3D;None)    print(done, pending)    asyncio.run(main())<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：<code>asyncio.wait</code> 源码内部会对列表中的每个协程执行ensure_future从而封装为Task对象，所以在和wait配合使用时task_list的值为<code>[func(),func()]</code> 也是可以的。</p><p><strong>示例3：</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import asyncioasync def func():    print(&quot;执行协程函数内部代码&quot;)    # 遇到IO操作挂起当前协程（任务），等IO操作完成之后再继续往下执行。当前协程挂起时，事件循环可以去执行其他协程（任务）。    response &#x3D; await asyncio.sleep(2)    print(&quot;IO请求结束，结果为：&quot;, response)        coroutine_list &#x3D; [func(), func()]# 错误：#coroutine_list &#x3D; [ #    asyncio.create_task(func()), #    asyncio.create_task(func())#]  # 此处不能直接 asyncio.create_task，因为将Task立即加入到事件循环的任务列表，# 但此时事件循环还未创建，所以会报错。# 使用asyncio.wait将列表封装为一个协程，并调用asyncio.run实现执行两个协程# asyncio.wait内部会对列表中的每个协程执行ensure_future，封装为Task对象。done,pending &#x3D; asyncio.run(asyncio.wait(coroutine_list) )print(done)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-2-4-asyncio-Future对象"><a href="#3-2-4-asyncio-Future对象" class="headerlink" title="3.2.4 asyncio.Future对象"></a>3.2.4 asyncio.Future对象</h4><blockquote><p>A <code>Future</code>is a special <strong>low-level</strong> awaitable object that represents an <strong>eventual result</strong> of an asynchronous operation.</p></blockquote><p>asyncio中的Future对象是一个相对更偏向底层的可对象，通常我们不会直接用到这个对象，而是直接使用Task对象来完成任务的并和状态的追踪。（ Task 是 Futrue的子类 ）</p><p>Future为我们提供了异步编程中的 最终结果 的处理（Task类也具备状态处理的功能）。</p><p>示例1：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">async def main():    # 获取当前事件循环    loop &#x3D; asyncio.get_running_loop()        # # 创建一个任务（Future对象），这个任务什么都不干。    fut &#x3D; loop.create_future()        # 等待任务最终结果（Future对象），没有结果则会一直等下去。    await fut    asyncio.run(main())<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>示例2：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import asyncioasync def set_after(fut):    await asyncio.sleep(2)    fut.set_result(&quot;666&quot;)    async def main():        # 获取当前事件循环        loop &#x3D; asyncio.get_running_loop()                # 创建一个任务（Future对象），没绑定任何行为，则这个任务永远不知道什么时候结束。        fut &#x3D; loop.create_future()                # 创建一个任务（Task对象），绑定了set_after函数，函数内部在2s之后，会给fut赋值。        # 即手动设置future任务的最终结果，那么fut就可以结束了。        await loop.create_task(set_after(fut))                # 等待 Future对象获取 最终结果，否则一直等下去        data &#x3D; await fut        print(data)        asyncio.run(main())<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Future对象本身函数进行绑定，所以想要让事件循环获取Future的结果，则需要手动设置。而Task对象继承了Future对象，其实就对Future进行扩展，他可以实现在对应绑定的函数执行完成之后，自动执行<code>set_result</code>，从而实现自动结束。</p><p>虽然，平时使用的是Task对象，但对于结果的处理本质是基于Future对象来实现的。</p><p>扩展：支持 <code>await 对象</code>语 法的对象课成为可等待对象，所以 <code>协程对象</code>、<code>Task对象</code>、<code>Future对象</code> 都可以被成为可等待对象。</p><h4 id="3-2-5-futures-Future对象"><a href="#3-2-5-futures-Future对象" class="headerlink" title="3.2.5 futures.Future对象"></a>3.2.5 futures.Future对象</h4><p>在Python的<code>concurrent.futures</code>模块中也有一个Future对象，这个对象是基于线程池和进程池实现异步操作时使用的对象。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import timefrom concurrent.futures import Futurefrom concurrent.futures.thread import ThreadPoolExecutorfrom concurrent.futures.process import ProcessPoolExecutordef func(value):    time.sleep(1)    print(value)    pool &#x3D; ThreadPoolExecutor(max_workers&#x3D;5)# 或 # pool &#x3D; ProcessPoolExecutor(max_workers&#x3D;5)        for i in range(10):        fut &#x3D; pool.submit(func, i)        print(fut)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>两个Future对象是不同的，他们是为不同的应用场景而设计，例如：<code>concurrent.futures.Future</code>不支持await语法 等。</p><p>官方提示两对象之间不同：</p><ul><li><p>unlike asyncio Futures, <a href="https://docs.python.org/3.8/library/concurrent.futures.html#concurrent.futures.Future"><code>concurrent.futures.Future</code></a> instances cannot be awaited.</p></li><li><p><a href="https://docs.python.org/3.8/library/asyncio-future.html#asyncio.Future.result"><code>asyncio.Future.result()</code></a> and <a href="https://docs.python.org/3.8/library/asyncio-future.html#asyncio.Future.exception"><code>asyncio.Future.exception()</code></a> do not accept the <em>timeout</em> argument.</p></li><li><p><a href="https://docs.python.org/3.8/library/asyncio-future.html#asyncio.Future.result"><code>asyncio.Future.result()</code></a> and <a href="https://docs.python.org/3.8/library/asyncio-future.html#asyncio.Future.exception"><code>asyncio.Future.exception()</code></a> raise an <a href="https://docs.python.org/3.8/library/asyncio-exceptions.html#asyncio.InvalidStateError"><code>InvalidStateError</code></a> exception when the Future is not <em>done</em>.</p></li><li><p>Callbacks registered with <a href="https://docs.python.org/3.8/library/asyncio-future.html#asyncio.Future.add_done_callback"><code>asyncio.Future.add_done_callback()</code></a> are not called immediately. They are scheduled with <a href="https://docs.python.org/3.8/library/asyncio-eventloop.html#asyncio.loop.call_soon"><code>loop.call_soon()</code></a> instead.</p></li><li><p>asyncio Future is not compatible with the <a href="https://docs.python.org/3.8/library/concurrent.futures.html#concurrent.futures.wait"><code>concurrent.futures.wait()</code></a> and <a href="https://docs.python.org/3.8/library/concurrent.futures.html#concurrent.futures.as_completed"><code>concurrent.futures.as_completed()</code></a> functions.</p></li></ul><p>在Python提供了一个将<code>futures.Future</code> 对象包装成<code>asyncio.Future</code>对象的函数 <code>asynic.wrap_future</code>。</p><p>接下里你肯定问：为什么python会提供这种功能？</p><p>其实，一般在程序开发中我们要么统一使用 asycio 的协程实现异步操作、要么都使用进程池和线程池实现异步操作。但如果 <code>协程的异步</code>和 <code>进程池/线程池的异步</code> 混搭时，那么就会用到此功能了。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import timeimport asyncioimport concurrent.futuresdef func1():    # 某个耗时操作    time.sleep(2)    return &quot;SB&quot;async def main():    loop &#x3D; asyncio.get_running_loop()        # 1. Run in the default loop&#39;s executor ( 默认ThreadPoolExecutor )    # 第一步：内部会先调用 ThreadPoolExecutor 的 submit 方法去线程池中申请一个线程去执行func1函数，并返回一个concurrent.futures.Future对象    # 第二步：调用asyncio.wrap_future将concurrent.futures.Future对象包装为asycio.Future对象。    # 因为concurrent.futures.Future对象不支持await语法，所以需要包装为 asycio.Future对象 才能使用。    fut &#x3D; loop.run_in_executor(None, func1)    result &#x3D; await fut    print(&#39;default thread pool&#39;, result)        # 2. Run in a custom thread pool:    # with concurrent.futures.ThreadPoolExecutor() as pool:    #     result &#x3D; await loop.run_in_executor(    #         pool, func1)    #     print(&#39;custom thread pool&#39;, result)        # 3. Run in a custom process pool:    # with concurrent.futures.ProcessPoolExecutor() as pool:    #     result &#x3D; await loop.run_in_executor(    #         pool, func1)    #     print(&#39;custom process pool&#39;, result)    asyncio.run(main())<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>应用场景：当项目以协程式的异步编程开发时，如果要使用一个第三方模块，而第三方模块不支持协程方式异步编程时，就需要用到这个功能，例如：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import asyncioimport requestsasyncdef download_image(url):    # 发送网络请求，下载图片（遇到网络下载图片的IO请求，自动化切换到其他任务）    print(&quot;开始下载:&quot;, url)        loop &#x3D; asyncio.get_event_loop()    # requests模块默认不支持异步操作，所以就使用线程池来配合实现了。    future &#x3D; loop.run_in_executor(None, requests.get, url)        response &#x3D; await future    print(&#39;下载完成&#39;)    # 图片保存到本地文件    file_name &#x3D; url.rsplit(&#39;_&#39;)[-1]    with open(file_name, mode&#x3D;&#39;wb&#39;) as file_object:        file_object.write(response.content)        if __name__ &#x3D;&#x3D; &#39;__main__&#39;:     url_list &#x3D; [                &#39;https:&#x2F;&#x2F;www3.autoimg.cn&#x2F;newsdfs&#x2F;g26&#x2F;M02&#x2F;35&#x2F;A9&#x2F;120x90_0_autohomecar__ChsEe12AXQ6AOOH_AAFocMs8nzU621.jpg&#39;,                &#39;https:&#x2F;&#x2F;www2.autoimg.cn&#x2F;newsdfs&#x2F;g30&#x2F;M01&#x2F;3C&#x2F;E2&#x2F;120x90_0_autohomecar__ChcCSV2BBICAUntfAADjJFd6800429.jpg&#39;,                &#39;https:&#x2F;&#x2F;www3.autoimg.cn&#x2F;newsdfs&#x2F;g26&#x2F;M0B&#x2F;3C&#x2F;65&#x2F;120x90_0_autohomecar__ChcCP12BFCmAIO83AAGq7vK0sGY193.jpg&#39;    ]    tasks &#x3D; [download_image(url) for url in url_list]         loop &#x3D; asyncio.get_event_loop()       loop.run_until_complete( asyncio.wait(tasks) )<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-2-6-异步迭代器"><a href="#3-2-6-异步迭代器" class="headerlink" title="3.2.6 异步迭代器"></a>3.2.6 异步迭代器</h4><p><strong>什么是异步迭代器</strong></p><p>实现了 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__aiter__"><code>__aiter__()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__anext__"><code>__anext__()</code></a> 方法的对象。<code>__anext__</code> 必须返回一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-awaitable">awaitable</a> 对象。<a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#async-for"><code>async for</code></a> 会处理异步迭代器的 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__anext__"><code>__anext__()</code></a> 方法所返回的可等待对象，直到其引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#StopAsyncIteration"><code>StopAsyncIteration</code></a> 异常。由 <a href="https://www.python.org/dev/peps/pep-0492"><strong>PEP 492</strong></a> 引入。</p><p><strong>什么是异步可迭代对象？</strong></p><p>可在 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#async-for"><code>async for</code></a> 语句中被使用的对象。必须通过它的 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__aiter__"><code>__aiter__()</code></a> 方法返回一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-asynchronous-iterator">asynchronous iterator</a>。由 <a href="https://www.python.org/dev/peps/pep-0492"><strong>PEP 492</strong></a> 引入。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import asyncioclass Reader(object):    &quot;&quot;&quot; 自定义异步迭代器（同时也是异步可迭代对象） &quot;&quot;&quot;        def __init__(self):        self.count &#x3D; 0            async def readline(self):        # await asyncio.sleep(1)        self.count +&#x3D; 1        if self.count &#x3D;&#x3D; 100:            return None        return self.count            def __aiter__(self):        return self            async def __anext__(self):        val &#x3D; await self.readline()        if val &#x3D;&#x3D; None:            raise StopAsyncIteration        return val            async def func():              # 创建异步可迭代对象        async_iter &#x3D; Reader()        # async for 必须要放在async def函数内，否则语法错误。        async for item in async_iter:            print(item)            asyncio.run(func())<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>异步迭代器其实没什么太大的作用，只是支持了async for语法而已。</p><h4 id="3-2-6-异步上下文管理器"><a href="#3-2-6-异步上下文管理器" class="headerlink" title="3.2.6 异步上下文管理器"></a>3.2.6 异步上下文管理器</h4><p>此种对象通过定义 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__aenter__"><code>__aenter__()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__aexit__"><code>__aexit__()</code></a> 方法来对 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#async-with"><code>async with</code></a> 语句中的环境进行控制。由 <a href="https://www.python.org/dev/peps/pep-0492"><strong>PEP 492</strong></a> 引入。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import asyncioclass AsyncContextManager:    def __init__(self):                self.conn &#x3D; conn                async def do_something(self):                    # 异步操作数据库                    return 666                    async def __aenter__(self):                    # 异步链接数据库            self.conn &#x3D; await asyncio.sleep(1)                    return self                  async def __aexit__(self, exc_type, exc, tb):               # 异步关闭数据库链接            await asyncio.sleep(1)            async def func():        async with AsyncContextManager() as f:                result &#x3D; await f.do_something()                    print(result)asyncio.run(func())        asyncio.run( func() )<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个异步的上下文管理器还是比较有用的，平时在开发过程中 打开、处理、关闭 操作时，就可以用这种方式来处理。</p><h3 id="3-3-小结"><a href="#3-3-小结" class="headerlink" title="3.3 小结"></a>3.3 小结</h3><p>在程序中只要看到<code>async</code>和<code>await</code>关键字，其内部就是基于协程实现的异步编程，这种异步编程是通过一个线程在IO等待时间去执行其他任务，从而实现并发。</p><p>以上就是异步编程的常见操作，内容参考官方文档。</p><ul><li>中文版：<a href="https://docs.python.org/zh-cn/3.8/library/asyncio.html">https://docs.python.org/zh-cn/3.8/library/asyncio.html</a></li><li>英文本：<a href="https://docs.python.org/3.8/library/asyncio.html">https://docs.python.org/3.8/library/asyncio.html</a></li></ul><h2 id="4-uvloop"><a href="#4-uvloop" class="headerlink" title="4. uvloop"></a>4. uvloop</h2><p>Python标准库中提供了<code>asyncio</code>模块，用于支持基于协程的异步编程。</p><p>uvloop是 asyncio 中的事件循环的替代方案，替换后可以使得asyncio性能提高。事实上，uvloop要比nodejs、gevent等其他python异步框架至少要快2倍，性能可以比肩Go语言。</p><p>安装uvloop</p><pre class="line-numbers language-none"><code class="language-none">pip3 install uvloop<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在项目中想要使用uvloop替换asyncio的事件循环也非常简单，只要在代码中这么做就行。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import asyncioimport uvloopasyncio.set_event_loop_policy(uvloop.EventLoopPolicy())# 编写asyncio的代码，与之前写的代码一致。# 内部的事件循环自动化会变为uvloopasyncio.run(...)asyncio.run(...)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：知名的asgi uvicorn内部就是使用的uvloop的事件循环。</p><h2 id="5-实战案例"><a href="#5-实战案例" class="headerlink" title="5.实战案例"></a>5.实战案例</h2><p>为了更好理解，上述所有示例的IO情况都是以 <code>asyncio.sleep</code> 为例，而真实的项目开发中会用到很多IO的情况。</p><h3 id="5-1-异步Redis"><a href="#5-1-异步Redis" class="headerlink" title="5.1 异步Redis"></a>5.1 异步Redis</h3><p>当通过python去操作redis时，链接、设置值、获取值 这些都涉及网络IO请求，使用asycio异步的方式可以在IO等待时去做一些其他任务，从而提升性能。</p><p>安装Python异步操作redis模块</p><pre class="line-numbers language-none"><code class="language-none">pip3 install aioredis<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>示例1：异步操作redis。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">#!&#x2F;usr&#x2F;bin&#x2F;env python# -*- coding:utf-8 -*-import asyncioimport aioredisasync def execute(address, password):    print(&quot;开始执行&quot;, address)    # 网络IO操作：创建redis连接    redis &#x3D; await aioredis.create_redis(address, password&#x3D;password)    # 网络IO操作：在redis中设置哈希值car，内部在设三个键值对，即： redis &#x3D; &#123; car:&#123;key1:1,key2:2,key3:3&#125;&#125;    await redis.hmset_dict(&#39;car&#39;, key1&#x3D;1, key2&#x3D;2, key3&#x3D;3)    # 网络IO操作：去redis中获取值    result &#x3D; await redis.hgetall(&#39;car&#39;, encoding&#x3D;&#39;utf-8&#39;)    print(result)    redis.close()    # 网络IO操作：关闭redis连接    await redis.wait_closed()    print(&quot;结束&quot;, address)asyncio.run( execute(&#39;redis:&#x2F;&#x2F;47.93.4.198:6379&#39;, &quot;root!2345&quot;) )<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>示例2：连接多个redis做操作（遇到IO会切换其他任务，提供了性能）。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import asyncioimport aioredisasync def execute(address, password):    print(&quot;开始执行&quot;, address)    # 网络IO操作：先去连接 47.93.4.197:6379，遇到IO则自动切换任务，去连接47.93.4.198:6379    redis &#x3D; await aioredis.create_redis_pool(address, password&#x3D;password)    # 网络IO操作：遇到IO会自动切换任务    await redis.hmset_dict(&#39;car&#39;, key1&#x3D;1, key2&#x3D;2, key3&#x3D;3)    # 网络IO操作：遇到IO会自动切换任务    result &#x3D; await redis.hgetall(&#39;car&#39;, encoding&#x3D;&#39;utf-8&#39;)    print(result)    redis.close()    # 网络IO操作：遇到IO会自动切换任务    await redis.wait_closed()    print(&quot;结束&quot;, address)task_list &#x3D; [    execute(&#39;redis:&#x2F;&#x2F;47.93.4.197:6379&#39;, &quot;root!2345&quot;),    execute(&#39;redis:&#x2F;&#x2F;47.93.4.198:6379&#39;, &quot;root!2345&quot;)]asyncio.run(asyncio.wait(task_list))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>更多redis操作参考aioredis官网：<a href="https://aioredis.readthedocs.io/en/v1.3.0/start.html">https://aioredis.readthedocs.io/en/v1.3.0/start.html</a></p><h3 id="5-2-异步MySQL"><a href="#5-2-异步MySQL" class="headerlink" title="5.2 异步MySQL"></a>5.2 异步MySQL</h3><p>当通过python去操作MySQL时，连接、执行SQL、关闭都涉及网络IO请求，使用asycio异步的方式可以在IO等待时去做一些其他任务，从而提升性能。</p><p>安装Python异步操作redis模块</p><pre class="line-numbers language-none"><code class="language-none">pip3 install aiomysql<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>示例1：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import asyncioimport aiomysqlasync def execute():    # 网络IO操作：连接MySQL    conn &#x3D; await aiomysql.connect(host&#x3D;&#39;127.0.0.1&#39;, port&#x3D;3306, user&#x3D;&#39;root&#39;, password&#x3D;&#39;123&#39;, db&#x3D;&#39;mysql&#39;, )    # 网络IO操作：创建CURSOR    cur &#x3D; await conn.cursor()    # 网络IO操作：执行SQL    await cur.execute(&quot;SELECT Host,User FROM user&quot;)    # 网络IO操作：获取SQL结果    result &#x3D; await cur.fetchall()    print(result)    # 网络IO操作：关闭链接    await cur.close()    conn.close()asyncio.run(execute())<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>示例2：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">#!&#x2F;usr&#x2F;bin&#x2F;env python# -*- coding:utf-8 -*-import asyncioimport aiomysqlasync def execute(host, password):    print(&quot;开始&quot;, host)    # 网络IO操作：先去连接 47.93.40.197，遇到IO则自动切换任务，去连接47.93.40.198:6379    conn &#x3D; await aiomysql.connect(host&#x3D;host, port&#x3D;3306, user&#x3D;&#39;root&#39;, password&#x3D;password, db&#x3D;&#39;mysql&#39;)    # 网络IO操作：遇到IO会自动切换任务    cur &#x3D; await conn.cursor()    # 网络IO操作：遇到IO会自动切换任务    await cur.execute(&quot;SELECT Host,User FROM user&quot;)    # 网络IO操作：遇到IO会自动切换任务    result &#x3D; await cur.fetchall()    print(result)    # 网络IO操作：遇到IO会自动切换任务    await cur.close()    conn.close()    print(&quot;结束&quot;, host)task_list &#x3D; [    execute(&#39;47.93.41.197&#39;, &quot;root!2345&quot;),    execute(&#39;47.93.40.197&#39;, &quot;root!2345&quot;)]asyncio.run(asyncio.wait(task_list))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-3-FastAPI框架"><a href="#5-3-FastAPI框架" class="headerlink" title="5.3 FastAPI框架"></a>5.3 FastAPI框架</h3><p>FastAPI是一款用于构建API的高性能web框架，框架基于Python3.6+的 <code>type hints</code>搭建。</p><p>接下里的异步示例以<code>FastAPI</code>和<code>uvicorn</code>来讲解（uvicorn是一个支持异步的asgi）。</p><p>安装FastAPI web 框架，</p><pre class="line-numbers language-none"><code class="language-none">pip3 install fastapi<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>安装uvicorn，本质上为web提供socket server的支持的asgi（一般支持异步称asgi、不支持异步称wsgi）</p><pre class="line-numbers language-none"><code class="language-none">pip3 install uvicorn<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">#!&#x2F;usr&#x2F;bin&#x2F;env python# -*- coding:utf-8 -*-import asyncioimport uvicornimport aioredisfrom aioredis import Redisfrom fastapi import FastAPIapp &#x3D; FastAPI()# 创建一个redis连接池REDIS_POOL &#x3D; aioredis.ConnectionsPool(&#39;redis:&#x2F;&#x2F;47.193.14.198:6379&#39;, password&#x3D;&quot;root123&quot;, minsize&#x3D;1, maxsize&#x3D;10)@app.get(&quot;&#x2F;&quot;)def index():    &quot;&quot;&quot; 普通操作接口 &quot;&quot;&quot;    return &#123;&quot;message&quot;: &quot;Hello World&quot;&#125;@app.get(&quot;&#x2F;red&quot;)async def red():    &quot;&quot;&quot; 异步操作接口 &quot;&quot;&quot;        print(&quot;请求来了&quot;)    await asyncio.sleep(3)    # 连接池获取一个连接    conn &#x3D; await REDIS_POOL.acquire()    redis &#x3D; Redis(conn)    # 设置值    await redis.hmset_dict(&#39;car&#39;, key1&#x3D;1, key2&#x3D;2, key3&#x3D;3)    # 读取值    result &#x3D; await redis.hgetall(&#39;car&#39;, encoding&#x3D;&#39;utf-8&#39;)    print(result)    # 连接归还连接池    REDIS_POOL.release(conn)    return resultif __name__ &#x3D;&#x3D; &#39;__main__&#39;:    uvicorn.run(&quot;luffy:app&quot;, host&#x3D;&quot;127.0.0.1&quot;, port&#x3D;5000, log_level&#x3D;&quot;info&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在有多个用户并发请求的情况下，异步方式来编写的接口可以在IO等待过程中去处理其他的请求，提供性能。</p><p>例如：同时有两个用户并发来向接口 <code>http://127.0.0.1:5000/red</code> 发送请求，服务端只有一个线程，同一时刻只有一个请求被处理。  异步处理可以提供并发是因为：当视图函数在处理第一个请求时，第二个请求此时是等待被处理的状态，当第一个请求遇到IO等待时，会自动切换去接收并处理第二个请求，当遇到IO时自动化切换至其他请求，一旦有请求IO执行完毕，则会再次回到指定请求向下继续执行其功能代码。</p><h3 id="5-4-爬虫"><a href="#5-4-爬虫" class="headerlink" title="5.4 爬虫"></a>5.4 爬虫</h3><p>在编写爬虫应用时，需要通过网络IO去请求目标数据，这种情况适合使用异步编程来提升性能，接下来我们使用支持异步编程的aiohttp模块来实现。</p><p>安装aiohttp模块</p><pre class="line-numbers language-none"><code class="language-none">pip3 install aiohttp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import aiohttpimport asyncioasync def fetch(session, url):    print(&quot;发送请求：&quot;, url)    async with session.get(url, verify_ssl&#x3D;False) as response:        text &#x3D; await response.text()        print(&quot;得到结果：&quot;, url, len(text))        return textasync def main():    async with aiohttp.ClientSession() as session:        url_list &#x3D; [            &#39;https:&#x2F;&#x2F;python.org&#39;,            &#39;https:&#x2F;&#x2F;www.baidu.com&#39;,            &#39;https:&#x2F;&#x2F;www.pythonav.com&#39;        ]        tasks &#x3D; [ asyncio.create_task(fetch(session, url)) for url in url_list]        done,pending &#x3D; await asyncio.wait(tasks)if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    asyncio.run( main() )<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>为了提升性能越来越多的框架都在向异步编程靠拢，例如：sanic、tornado、django3.0、django channels组件 等，用更少资源可以做处理更多的事，何乐而不为呢。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>清华pip镜像</title>
      <link href="/2021/04/10/qing-hua-pip-jing-xiang/"/>
      <url>/2021/04/10/qing-hua-pip-jing-xiang/</url>
      
        <content type="html"><![CDATA[<h1 id="清华pip镜像使用方法"><a href="#清华pip镜像使用方法" class="headerlink" title="清华pip镜像使用方法"></a>清华pip镜像使用方法</h1><p>pip install -i <a href="https://pypi.tuna.tsinghua.edu.cn/simple">https://pypi.tuna.tsinghua.edu.cn/simple</a> xxx<br>xxx表示的是第三方库的名字</p>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tools </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
