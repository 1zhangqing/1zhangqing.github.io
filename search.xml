<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>逆序对的数量（归并排序的应用）</title>
      <link href="2021/07/11/ni-xu-dui-de-shu-liang-gui-bing-pai-xu-de-ying-yong/"/>
      <url>2021/07/11/ni-xu-dui-de-shu-liang-gui-bing-pai-xu-de-ying-yong/</url>
      
        <content type="html"><![CDATA[<h1 id="逆序对的数量（归并排序的应用）"><a href="#逆序对的数量（归并排序的应用）" class="headerlink" title="逆序对的数量（归并排序的应用）"></a><center>逆序对的数量（归并排序的应用）</center></h1><p>原题链接<a href="https://www.acwing.com/problem/content/790/">788. 逆序对的数量 - AcWing题库</a></p><p><img src="C:\Users\一丈青\AppData\Roaming\Typora\typora-user-images\image-20210712000257663.png" alt="image-20210712000257663"></p><p>模板：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;using namespace std;const int N &#x3D; 1e5 + 10;int q[N],tmp[N];typedef long long ll;ll merge_sort (int q[], int l, int r)&#123;    if (l &gt;&#x3D; r) return 0;    int mid &#x3D; l + r &gt;&gt; 1;    ll ans &#x3D; merge_sort(q, l, mid) + merge_sort(q, mid + 1, r);    int k &#x3D; 0, i &#x3D; l, j &#x3D; mid + 1;    while (i &lt;&#x3D; mid &amp;&amp; j &lt;&#x3D; r)    &#123;        if (q[i] &lt;&#x3D; q[j]) tmp[k ++ ] &#x3D; q[i ++ ];        else         &#123;            tmp[k ++ ] &#x3D; q[j ++ ];            ans +&#x3D; mid - i + 1;        &#125;    &#125;    while (i &lt;&#x3D; mid) tmp[k ++ ] &#x3D; q[i ++ ];    while (j &lt;&#x3D; r) tmp[k ++ ] &#x3D; q[j ++ ];        for (int i &#x3D; l, j &#x3D; 0; i &lt;&#x3D; r; i ++, j ++ ) q[i] &#x3D; tmp[j];        return ans;&#125;int main()&#123;    int n;    scanf(&quot;%d&quot;, &amp;n);    for (int i &#x3D; 0; i &lt; n; i ++ ) scanf(&quot;%d&quot;, &amp;q[i]);    cout &lt;&lt; merge_sort(q, 0, n - 1) &lt;&lt; endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>归并排序</title>
      <link href="2021/07/11/gui-bing-pai-xu/"/>
      <url>2021/07/11/gui-bing-pai-xu/</url>
      
        <content type="html"><![CDATA[<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a><center>归并排序</center></h1><p>原题链接</p><p>归并排序是稳定的<br>排序的稳定：指排序后两个相同值的顺序不会变<br>没有实际用途，但会考</p><p><img src="C:\Users\一丈青\AppData\Roaming\Typora\typora-user-images\image-20210711222003318.png" alt="image-20210711222003318"></p><p>模板：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;const int N &#x3D; 1e6 + 10;int a[N], tmp[N];void merge_sort(int q[], int l, int r)&#123;    if (l &gt;&#x3D; r) return;    int mid &#x3D; l + r &gt;&gt; 1;    merge_sort(q, l, mid), merge_sort(q, mid + 1, r);    int k &#x3D; 0, i &#x3D; l, j &#x3D; mid + 1;    while (i &lt;&#x3D; mid &amp;&amp; j &lt;&#x3D; r)        if (q[i] &lt;&#x3D; q[j]) tmp[k ++ ] &#x3D; q[i ++ ];        else tmp[k ++ ] &#x3D; q[j ++ ];    while (i &lt;&#x3D; mid) tmp[k ++ ] &#x3D; q[i ++ ];    while (j &lt;&#x3D; r) tmp[k ++ ] &#x3D; q[j ++ ];    for (i &#x3D; l, j &#x3D; 0; i &lt;&#x3D; r; i ++, j ++ ) q[i] &#x3D; tmp[j];&#125;int main()&#123;    int n;    scanf(&quot;%d&quot;, &amp;n);    for (int i &#x3D; 0; i &lt; n; i ++ ) scanf(&quot;%d&quot;, &amp;a[i]);    merge_sort(a, 0, n - 1);    for (int i &#x3D; 0; i &lt; n; i ++ ) printf(&quot;%d &quot;, a[i]);    return 0;&#125;作者：yxc链接：https:&#x2F;&#x2F;www.acwing.com&#x2F;activity&#x2F;content&#x2F;code&#x2F;content&#x2F;39790&#x2F;来源：AcWing著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第k个数（快速选择算法）</title>
      <link href="2021/07/11/di-k-ge-shu-kuai-su-xuan-ze-suan-fa/"/>
      <url>2021/07/11/di-k-ge-shu-kuai-su-xuan-ze-suan-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="第k个数（快速选择算法）"><a href="#第k个数（快速选择算法）" class="headerlink" title="第k个数（快速选择算法）"></a><center>第k个数（快速选择算法）</center></h1><p>原题链接<a href="https://www.acwing.com/problem/content/description/788/">786. 第k个数 - AcWing题库</a></p><p>另一种思路<a href="https://www.acwing.com/solution/acwing/content/4502/">AcWing 786. 写一个和yxc大佬不同但差不多思想的方法，代码更简单 - AcWing</a></p><p>模板（快速排序的应用）：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;using namespace std;const int N &#x3D; 100010;int q[N];int quick_sort(int l, int r, int k)&#123;    if(l &#x3D;&#x3D; r) return q[l];    int i &#x3D; l - 1, j &#x3D; r + 1, x &#x3D; q[l + r &gt;&gt; 1];    while (i &lt; j)    &#123;        do i ++; while (q[i] &lt; x);        do j --; while (q[j] &gt; x);        if (i &lt; j) swap(q[i], q[j]);    &#125;    int sl &#x3D; j - l + 1;    if(k &lt;&#x3D; sl) return quick_sort(l, j, k);    else return quick_sort(j + 1, r, k - sl);&#125;int main()&#123;    int n,k;    scanf(&quot;%d%d&quot;, &amp;n, &amp;k);    for(int i &#x3D; 0; i &lt; n; i ++) scanf(&quot;%d&quot;, &amp;q[i]);    printf(&quot;%d&quot;, quick_sort(0, n - 1, k));    &#x2F;&#x2F;cout &lt;&lt; quick_sort(0, n - 1, k) &lt;&lt; endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> STL解法：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;const int N&#x3D;1000000 +1000;int a[N],n,m,i,j,k;int main()&#123;    ios::sync_with_stdio(false);    cin&gt;&gt;n&gt;&gt;m;    for(int i&#x3D;1;i&lt;&#x3D;n;i++)        cin&gt;&gt;a[i];    sort(a+1,a+1+n);    cout&lt;&lt;a[m];&#x2F;&#x2F;排序快乐    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速排序</title>
      <link href="2021/07/11/kuai-su-pai-xu/"/>
      <url>2021/07/11/kuai-su-pai-xu/</url>
      
        <content type="html"><![CDATA[<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a><center>快速排序</center></h1><p>原题链接<a href="https://www.acwing.com/problem/content/787/">785. 快速排序 - AcWing题库</a></p><p>题解链接<a href="https://www.acwing.com/solution/content/2096/">AcWing 785. 快速排序 - AcWing</a></p><p>视频题解链接<a href="https://www.acwing.com/video/227/">AcWing 785. 快速排序 - AcWing</a></p><p>各类排序对比：</p><p><img src="C:\Users\一丈青\AppData\Roaming\Typora\typora-user-images\image-20210711214016030.png" alt="image-20210711214016030"></p><p>ios::sync_with_stdio(false);<br>该语句可以使得cin输入速度相比scanf差不多，一般大多数情况下scanf快</p><p>模板如下：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;const int N &#x3D; 1000010;int q[N];void quick_sort(int q[], int l, int r)&#123;    if (l &gt;&#x3D; r) return;    int i &#x3D; l - 1, j &#x3D; r + 1, x &#x3D; q[l + r &gt;&gt; 1];    while (i &lt; j)    &#123;        do i ++ ; while (q[i] &lt; x);        do j -- ; while (q[j] &gt; x);        if (i &lt; j) swap(q[i], q[j]);    &#125;    quick_sort(q, l, j);    quick_sort(q, j + 1, r);&#125;int main()&#123;    int n;    scanf(&quot;%d&quot;, &amp;n);    for (int i &#x3D; 0; i &lt; n; i ++ ) scanf(&quot;%d&quot;, &amp;q[i]);    quick_sort(q, 0, n - 1);    for (int i &#x3D; 0; i &lt; n; i ++ ) printf(&quot;%d &quot;, q[i]);    return 0;&#125;作者：yxc链接：https:&#x2F;&#x2F;www.acwing.com&#x2F;activity&#x2F;content&#x2F;code&#x2F;content&#x2F;39784&#x2F;来源：AcWing著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>C++STL快速算法：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;const int N&#x3D;1000000+100;int a[N],n,m,i,j;int main()&#x2F;&#x2F;C++ Stl使人快乐&#123;    ios::sync_with_stdio(false);&#x2F;&#x2F;使cin能在多数情况下速度                                &#x2F;&#x2F;和scanf相比差不多    &#x2F;&#x2F;最好用scanf，在c++中是最快的    cin&gt;&gt;n;    for(int i&#x3D;1;i&lt;&#x3D;n;i++)        cin&gt;&gt;a[i];    sort(a+1,a+1+n);    for(int i&#x3D;1;i&lt;&#x3D;n;i++)        cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;;    cout&lt;&lt;endl;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo注意事项和常用命令</title>
      <link href="2021/05/03/hexo-zhu-yi-shi-xiang-he-chang-yong-ming-ling/"/>
      <url>2021/05/03/hexo-zhu-yi-shi-xiang-he-chang-yong-ming-ling/</url>
      
        <content type="html"><![CDATA[<h1 id="hexo注意事项和常用命令"><a href="#hexo注意事项和常用命令" class="headerlink" title="hexo注意事项和常用命令"></a>hexo注意事项和常用命令</h1><p><strong>我的博客网站：</strong></p><p>Gitee：<a href="http://yizhangqing.gitee.io/">一丈青 (gitee.io)</a></p><p>GitHub：<a href="https://1zhangqing.github.io/">一丈青 (1zhangqing.github.io)</a></p><ol><li><p>自己手写front-matter块出来的方法：写—（三个减号符号-）然后回车就能出现写front-matter的块来，里面可以配置参数如下：</p><table><thead><tr><th align="center">参数</th><th align="center">描述</th><th align="center">默认值</th></tr></thead><tbody><tr><td align="center"><code>layout</code></td><td align="center">布局</td><td align="center"><a href="https://hexo.io/zh-cn/docs/configuration#%E6%96%87%E7%AB%A0"><code>config.default_layout</code></a></td></tr><tr><td align="center"><code>title</code></td><td align="center">标题</td><td align="center">文章的文件名</td></tr><tr><td align="center"><code>date</code></td><td align="center">建立日期</td><td align="center">文件建立日期</td></tr><tr><td align="center"><code>updated</code></td><td align="center">更新日期</td><td align="center">文件更新日期</td></tr><tr><td align="center"><code>comments</code></td><td align="center">开启文章的评论功能</td><td align="center">true</td></tr><tr><td align="center"><code>tags</code></td><td align="center">标签（不适用于分页）</td><td align="center"></td></tr><tr><td align="center"><code>categories</code></td><td align="center">分类（不适用于分页）</td><td align="center"></td></tr><tr><td align="center"><code>permalink</code></td><td align="center">覆盖文章网址</td><td align="center"></td></tr><tr><td align="center"><code>excerpt</code></td><td align="center">Page excerpt in plain text. Use <a href="https://hexo.io/docs/tag-plugins#Post-Excerpt">this plugin</a> to format the text</td><td align="center"></td></tr><tr><td align="center"><code>disableNunjucks</code></td><td align="center">Disable rendering of Nunjucks tag <code>&#123;&#123; &#125;&#125;</code>/<code>&#123;% %&#125;</code> and <a href="https://hexo.io/docs/tag-plugins">tag plugins</a> when enabled</td><td align="center"></td></tr><tr><td align="center"><code>lang</code></td><td align="center">Set the language to override <a href="https://hexo.io/docs/internationalization#Path">auto-detection</a></td><td align="center">Inherited from <code>_config.yml</code></td></tr></tbody></table></li><li><p>```shell<br>hexo init [folder]</p><pre class="line-numbers language-none"><code class="language-none">   初始化一个博客3. &#96;&#96;&#96;shell   hexo new [layout] &lt;title&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>新建一篇文章，在BLOG文件下下git bush或者在BLOG/suorce/_post文件夹下git bush后输入该命令</p></li><li><p>```shell<br>hexo generate</p><pre class="line-numbers language-none"><code class="language-none">生成静态页面可简写为&#96;&#96;&#96;shellhexo g<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>```shell<br>hexo new draft 草稿文件名</p><pre class="line-numbers language-none"><code class="language-none">新建草稿(草稿不会发表，会存储在source&#x2F;_drafts文件下)&#96;&#96;&#96;shellhexo publish 草稿文件名<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>发表草稿</p></li><li><p>```shell<br>hexo server</p><pre class="line-numbers language-none"><code class="language-none">启动服务器可简写为&#96;&#96;&#96;shellhexo s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>```shell<br>hexo deploy</p><pre class="line-numbers language-none"><code class="language-none">部署网站可简写为&#96;&#96;&#96;shellhexo d<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>```shell<br>hexo clean</p><pre class="line-numbers language-none"><code class="language-none">   清除缓存文件 (&#96;db.json&#96;) 和已生成的静态文件 (&#96;public&#96;)。   在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。9. &#96;&#96;&#96;shell   hexo --draft<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>显示 <code>source/_drafts</code> 文件夹中的草稿文章</p></li><li><p><strong>写一篇博客并上传的步骤流程</strong><br>在BLOG文件目录下git bush here后输入hexo new [layout] filename 新建一篇博客<br>在博客中用markdown语法写完博客后<br>在BLOG文件目录下git bush here<br>在命令终端hexo clean清除缓存，然后hexo g生成静态页面，然后hexo s启动本地服务器在本地预览结果（可省略），最后hexo d部署<br>在BLOG文件夹下的_config.yml中可以查看或者配置部署地址<br>其中gitee的部署后还要再到gitee仓库里手动部署网站，GitHub则不用</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">hexo g -d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这是直接生成静态页面并上传的简化命令</p></li><li><p>上传到Gitee或者GitHub上时在_config.yml里面改deploy参数，如下图：<img src=".%5Chexo%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E5%92%8C%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%5Cimage-20220528000432374.png" alt="image-20220528000432374"></p></li><li><p>忘记命令一个快捷的方式就是在终端直接输入hexo后按回车，它会提示你常用命令。</p></li><li><p>博客多平台部署参考：<a href="https://gitee.com/help/articles/4136#article-header0">https://gitee.com/help/articles/4136#article-header0</a></p></li><li><p>hexo操作官方文档<a href="https://hexo.io/zh-cn/docs/">文档 | Hexo</a></p></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Markdown语法注意事项</title>
      <link href="2021/05/03/markdown-yu-fa-zhu-yi-shi-xiang/"/>
      <url>2021/05/03/markdown-yu-fa-zhu-yi-shi-xiang/</url>
      
        <content type="html"><![CDATA[<h1 id="Markdown语法注意事项"><a href="#Markdown语法注意事项" class="headerlink" title="Markdown语法注意事项"></a><center>Markdown语法注意事项</center></h1><ol><li><p>使用#来搞标题记得要有空格即     # markdown语法注意事项<br>如果要居中之后再加粗使用标题的话就在&lt;center&gt;前加#并空格<br>一个#是一级标题，两个是二级标题，依此类推。</p></li><li><p>-+空格+[]+空格+文字 （注：注意用空格隔开）<br>可以写出代办任务  </p><ul><li><input disabled="" type="checkbox"> </li></ul></li><li><p>-+空格+[x]+空格+文字<br>可以写出已办事项  </p><ul><li><input checked="" disabled="" type="checkbox"> </li></ul></li><li><p>+ 、- 、* 创建无序列，任意数字开始+空格创建有序列表。在创建有序列表的时候，输入创建的操作就是先输入“序号.”在后面加上空格，如“1. ”这样就可以得到有序列表的第一行了。</p></li><li><blockquote><p>与天奋斗，其乐无穷！与地奋斗，其乐无穷！与人奋斗，其乐无穷！</p><p>——《毛泽东选集》之《奋斗自勉》</p></blockquote><p>上诉即为引用，引用格式为&gt;+空格</p></li><li><p><strong>空格：</strong>在输入连续的空格后，Typora 会在编辑器视图里为你保留这些空格，但当你打印或导出时，这些空格会被省略成一个。 你可以在源代码模式下，为每个空格前加一个 <code>\</code> 转义符，或者直接使用 HTML 风格的 <code>&amp;nbps;</code> 来保持连续的空格。</p></li><li><p><strong>软换行：</strong>需要说明的是，在 Markdown 语法中，换行（line break）与换段是不同的。且换行分为软换行和硬换行。在 Typora 中，你可以通过 <code>Shift + Enter</code> 完成一次软换行。软换行只在编辑界面可见，当文档被导出时换行会被省略。</p></li><li><p><strong>硬换行：</strong>你可以通过 <code>空格 + 空格 + Shift + Enter</code> 完成一次硬换行，而这也是许多 Markdown 编辑器所原生支持的。硬换行在文档被导出时将被保留，且没有换段的段后距。</p></li><li><p><strong>换段：</strong>你可以通过 <code>Enter</code> 完成一次换段。Typora 会自动帮你完成两次 <code>Shift + Enter</code> 的软换行，从而完成一次换段。这也意味着在 Markdown 语法下，换段是通过在段与段之间加入空行来实现的。</p></li><li><p><strong>Typora 中代码的插入也可以分为行内和块间两种：</strong></p></li><li><p><strong>行内代码：</strong>用 <code>...</code> 或 <code>...</code> 括起代码，代码会以主题中设置的样式出现在行内，但不会实现代码高亮。</p></li><li><p><strong>代码块：</strong>输入 ```后并输入语言名，换行，开始写代码，Typora 就会自动帮你实现代码高亮。Typora 原生支持许多编程语言代码块的语法高亮，基本日常常用的编程语言它都能很好地支持。 除此以外，你也可以直接换行开始写，而后再选择语言。</p></li><li><p><strong>「打字机模式」</strong>使得所编辑的那一行永远处于屏幕正中。</p></li><li><p><strong>「专注模式」</strong>正在编辑的那一行保留颜色，而其他行的字体呈灰色。</p></li><li><p>Typora 的图片插入功能是广受好评的。要知道，Markdown 原生不太注重图片插入的功能，但你可以在 Typora 中：</p><ul><li><p>直接使用 <code>右键 - 复制 Ctrl + V</code> 将网络图片、剪贴板图片复制到文档中</p></li><li><p>拖动本地图片到文档中</p><p> Typora 会自动帮你插入符合 Markdown 语法的图片语句，并给它加上标题。</p><p> 更强大的是，Typora 支持在拖动或 <code>Ctrl + V</code> 网络图片后自动将其保存到本地。你可以在 <code>文件 - 偏好设置 - 编辑器 - 图片插入</code> 中选择复制到哪个路径，什么情况下需要复制。</p></li></ul></li><li><h5 id="上下标与注释"><a href="#上下标与注释" class="headerlink" title="上下标与注释"></a><strong>上下标与注释</strong></h5><ul><li>上标的另外一种写法是<code>文本^上标^</code> 例如：y^2^ 的写法是<code>y^2^</code></li><li>下标语法是使用<code>~</code>包裹，例如：H<del>2</del> 的写法就是<code>H~2~</code></li></ul></li></ol><pre class="line-numbers language-python" data-language="python"><code class="language-python">#这是代码块注释这不是代码块注释<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol start="17"><li>直接在Typora中右键则可插入代码块，有序无序序列，链接，代办未办事项等等。</li></ol><!--这是非代码块的注释--><!--zheshizhushi--><ol start="18"><li>在 Typora 中，用 <code>:emoji:</code> 的形式来打出 emoji，软件会自动给出图形的提示。(下附Typora中的emoji表情大全链接)<br>可以通过使用<code>ESC</code>键触发表情建议补全功能，也可在功能面板启用后自动触发此功能。同时，直接从菜单栏<code>Edit</code> -&gt; <code>Emoji &amp; Symbols</code>插入UTF8表情符号(快捷键win+。句号)<br>或者使用下面的方法<br>访问网站 <a href="https://emojikeyboard.org/%EF%BC%8C%E6%89%BE%E5%88%B0%E9%9C%80%E8%A6%81%E7%9A%84%E7%AC%A6%E5%8F%B7%EF%BC%8C%E9%BC%A0%E6%A0%87%E5%B7%A6%E9%94%AE%E5%8D%95%E5%87%BB%EF%BC%8C%E7%84%B6%E5%90%8E%E7%B2%98%E8%B4%B4%E5%88%B0%E9%9C%80%E8%A6%81%E7%9A%84%E5%9C%B0%E6%96%B9%E5%B0%B1%E8%A1%8C%E4%BA%86%EF%BC%81:ok_hand">https://emojikeyboard.org/，找到需要的符号，鼠标左键单击，然后粘贴到需要的地方就行了！:ok_hand</a>:</li></ol><p>本文参考:</p><p><a href="https://www.jianshu.com/p/ebe52d2d468f">Markdown语法大全(超级版) - 简书 (jianshu.com)</a><br><a href="https://www.cnblogs.com/hyz-it/p/13662304.html">Typora常用功能使用详解 - Learning-没death - 博客园 (cnblogs.com)</a><br><a href="https://blog.csdn.net/mollen/article/details/84110708">TYPORA语法大全_mollen的博客-CSDN博客_typora语法</a><br><a href="https://blog.csdn.net/mingzhuo_126/article/details/82722455">使用Typora添加数学公式_姚明明的博客-CSDN博客_typora数学公式</a><br><a href="https://blog.csdn.net/weixin_42395140/article/details/111642339">(1条消息) Typora中的emoji表情_江蓠-的博客-CSDN博客_typora表情</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CSDN自带markdown编辑器</title>
      <link href="2021/05/03/csdn-zi-dai-markdown-bian-ji-qi/"/>
      <url>2021/05/03/csdn-zi-dai-markdown-bian-ji-qi/</url>
      
        <content type="html"><![CDATA[<p>@<a href="%E8%BF%99%E9%87%8C%E5%86%99%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9B%AE%E5%BD%95%E6%A0%87%E9%A2%98">TOC</a></p><h1 id="欢迎使用Markdown编辑器"><a href="#欢迎使用Markdown编辑器" class="headerlink" title="欢迎使用Markdown编辑器"></a>欢迎使用Markdown编辑器</h1><p>你好！ 这是你第一次使用 <strong>Markdown编辑器</strong> 所展示的欢迎页。如果你想学习如何使用Markdown编辑器, 可以仔细阅读这篇文章，了解一下Markdown的基本语法知识。</p><h2 id="新的改变"><a href="#新的改变" class="headerlink" title="新的改变"></a>新的改变</h2><p>我们对Markdown编辑器进行了一些功能拓展与语法支持，除了标准的Markdown编辑器功能，我们增加了如下几点新功能，帮助你用它写博客：</p><ol><li><strong>全新的界面设计</strong> ，将会带来全新的写作体验；</li><li>在创作中心设置你喜爱的代码高亮样式，Markdown <strong>将代码片显示选择的高亮样式</strong> 进行展示；</li><li>增加了 <strong>图片拖拽</strong> 功能，你可以将本地的图片直接拖拽到编辑区域直接展示；</li><li>全新的 <strong>KaTeX数学公式</strong> 语法；</li><li>增加了支持<strong>甘特图的mermaid语法<a href="%5Bmermaid%E8%AF%AD%E6%B3%95%E8%AF%B4%E6%98%8E%5D(https://mermaidjs.github.io/)">^1</a></strong> 功能；</li><li>增加了 <strong>多屏幕编辑</strong> Markdown文章功能；</li><li>增加了 <strong>焦点写作模式、预览模式、简洁写作模式、左右区域同步滚轮设置</strong> 等功能，功能按钮位于编辑区域与预览区域中间；</li><li>增加了 <strong>检查列表</strong> 功能。</li></ol><h2 id="功能快捷键"><a href="#功能快捷键" class="headerlink" title="功能快捷键"></a>功能快捷键</h2><p>撤销：<kbd>Ctrl/Command</kbd> + <kbd>Z</kbd><br>重做：<kbd>Ctrl/Command</kbd> + <kbd>Y</kbd><br>加粗：<kbd>Ctrl/Command</kbd> + <kbd>B</kbd><br>斜体：<kbd>Ctrl/Command</kbd> + <kbd>I</kbd><br>标题：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>H</kbd><br>无序列表：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>U</kbd><br>有序列表：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>O</kbd><br>检查列表：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>C</kbd><br>插入代码：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>K</kbd><br>插入链接：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>L</kbd><br>插入图片：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>G</kbd><br>查找：<kbd>Ctrl/Command</kbd> + <kbd>F</kbd><br>替换：<kbd>Ctrl/Command</kbd> + <kbd>G</kbd></p><h2 id="合理的创建标题，有助于目录的生成"><a href="#合理的创建标题，有助于目录的生成" class="headerlink" title="合理的创建标题，有助于目录的生成"></a>合理的创建标题，有助于目录的生成</h2><p>直接输入1次<kbd>#</kbd>，并按下<kbd>space</kbd>后，将生成1级标题。<br>输入2次<kbd>#</kbd>，并按下<kbd>space</kbd>后，将生成2级标题。<br>以此类推，我们支持6级标题。有助于使用<code>TOC</code>语法后生成一个完美的目录。</p><h2 id="如何改变文本的样式"><a href="#如何改变文本的样式" class="headerlink" title="如何改变文本的样式"></a>如何改变文本的样式</h2><p><em>强调文本</em> <em>强调文本</em></p><p><strong>加粗文本</strong> <strong>加粗文本</strong></p><p>==标记文本==</p><p><del>删除文本</del></p><blockquote><p>引用文本</p></blockquote><p>H<del>2</del>O is是液体。</p><p>2^10^ 运算结果是 1024.</p><h2 id="插入链接与图片"><a href="#插入链接与图片" class="headerlink" title="插入链接与图片"></a>插入链接与图片</h2><p>链接: <a href="https://www.csdn.net/">link</a>.</p><p>图片: <img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hdmF0YXIuY3Nkbi5uZXQvNy83L0IvMV9yYWxmX2h4MTYzY29tLmpwZw" alt="Alt"></p><p>带尺寸的图片: ![Alt](<a href="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hdmF0YXIuY3Nkbi5uZXQvNy83L0IvMV9yYWxmX2h4MTYzY29tLmpwZw">https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hdmF0YXIuY3Nkbi5uZXQvNy83L0IvMV9yYWxmX2h4MTYzY29tLmpwZw</a> =30x30)</p><p>居中的图片: <img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hdmF0YXIuY3Nkbi5uZXQvNy83L0IvMV9yYWxmX2h4MTYzY29tLmpwZw#pic_center" alt="Alt"></p><p>居中并且带尺寸的图片: ![Alt](<a href="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hdmF0YXIuY3Nkbi5uZXQvNy83L0IvMV9yYWxmX2h4MTYzY29tLmpwZw#pic_center">https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hdmF0YXIuY3Nkbi5uZXQvNy83L0IvMV9yYWxmX2h4MTYzY29tLmpwZw#pic_center</a> =30x30)</p><p>当然，我们为了让用户更加便捷，我们增加了图片拖拽功能。</p><h2 id="如何插入一段漂亮的代码片"><a href="#如何插入一段漂亮的代码片" class="headerlink" title="如何插入一段漂亮的代码片"></a>如何插入一段漂亮的代码片</h2><p>去<a href="https://mp.csdn.net/console/configBlog">博客设置</a>页面，选择一款你喜欢的代码片高亮样式，下面展示同样高亮的 <code>代码片</code>.</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// An highlighted block</span><span class="token keyword">var</span> foo <span class="token operator">=</span> <span class="token string">'bar'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="生成一个适合你的列表"><a href="#生成一个适合你的列表" class="headerlink" title="生成一个适合你的列表"></a>生成一个适合你的列表</h2><ul><li>项目<ul><li>项目<ul><li>项目</li></ul></li></ul></li></ul><ol><li>项目1</li><li>项目2</li><li>项目3</li></ol><ul><li><input disabled="" type="checkbox"> 计划任务</li><li><input checked="" disabled="" type="checkbox"> 完成任务</li></ul><h2 id="创建一个表格"><a href="#创建一个表格" class="headerlink" title="创建一个表格"></a>创建一个表格</h2><p>一个简单的表格是这么创建的：<br>| 项目 | Value |<br>| —- | —– |<br>| 电脑 | $1600 |<br>| 手机 | $12   |<br>| 导管 | $1    |</p><h3 id="设定内容居中、居左、居右"><a href="#设定内容居中、居左、居右" class="headerlink" title="设定内容居中、居左、居右"></a>设定内容居中、居左、居右</h3><p>使用<code>:---------:</code>居中<br>使用<code>:----------</code>居左<br>使用<code>----------:</code>居右<br>|     第一列     |         第二列 | 第三列         |<br>| :————: | ————-: | :————- |<br>| 第一列文本居中 | 第二列文本居右 | 第三列文本居左 |</p><h3 id="SmartyPants"><a href="#SmartyPants" class="headerlink" title="SmartyPants"></a>SmartyPants</h3><p>SmartyPants将ASCII标点字符转换为“智能”印刷标点HTML实体。例如：<br>|    TYPE   |ASCII                          |HTML<br>|—————-|——————————-|—————————–|<br>|Single backticks|<code>&#39;Isn&#39;t this fun?&#39;</code>            |’Isn’t this fun?’            |<br>|Quotes          |<code>&quot;Isn&#39;t this fun?&quot;</code>            |”Isn’t this fun?”            |<br>|Dashes          |<code>-- is en-dash, --- is em-dash</code>|– is en-dash, — is em-dash|</p><h2 id="创建一个自定义列表"><a href="#创建一个自定义列表" class="headerlink" title="创建一个自定义列表"></a>创建一个自定义列表</h2><dl><dt>Markdown</dt><dd>Text-to-HTML conversion tool</dd></dl><dl><dt>Authors<br>:  John</dt><dd>Luke</dd></dl><h2 id="如何创建一个注脚"><a href="#如何创建一个注脚" class="headerlink" title="如何创建一个注脚"></a>如何创建一个注脚</h2><p>一个具有注脚的文本。<a href="%E6%B3%A8%E8%84%9A%E7%9A%84%E8%A7%A3%E9%87%8A">^2</a></p><h2 id="注释也是必不可少的"><a href="#注释也是必不可少的" class="headerlink" title="注释也是必不可少的"></a>注释也是必不可少的</h2><p>Markdown将文本转换为 HTML。</p><p>*[HTML]:   超文本标记语言</p><h2 id="KaTeX数学公式"><a href="#KaTeX数学公式" class="headerlink" title="KaTeX数学公式"></a>KaTeX数学公式</h2><p>您可以使用渲染LaTeX数学表达式 <a href="https://khan.github.io/KaTeX/">KaTeX</a>:</p><p>Gamma公式展示 $\Gamma(n) = (n-1)!\quad\forall<br>n\in\mathbb N$ 是通过欧拉积分</p><p>$$<br>\Gamma(z) = \int_0^\infty t^{z-1}e^{-t}dt,.<br>$$</p><blockquote><p>你可以找到更多关于的信息 <strong>LaTeX</strong> 数学表达式<a href="http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference">here</a>.</p></blockquote><h2 id="新的甘特图功能，丰富你的文章"><a href="#新的甘特图功能，丰富你的文章" class="headerlink" title="新的甘特图功能，丰富你的文章"></a>新的甘特图功能，丰富你的文章</h2><pre class="line-numbers language-mermaid" data-language="mermaid"><code class="language-mermaid">gantt        dateFormat  YYYY-MM-DD        title Adding GANTT diagram functionality to mermaid        section 现有任务        已完成               :done,    des1, 2014-01-06,2014-01-08        进行中               :active,  des2, 2014-01-09, 3d        计划一               :         des3, after des2, 5d        计划二               :         des4, after des3, 5d<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>关于 <strong>甘特图</strong> 语法，参考 <a href="https://mermaidjs.github.io/">这儿</a>,</li></ul><h2 id="UML-图表"><a href="#UML-图表" class="headerlink" title="UML 图表"></a>UML 图表</h2><p>可以使用UML图表进行渲染。 <a href="https://mermaidjs.github.io/">Mermaid</a>. 例如下面产生的一个序列图：</p><pre class="line-numbers language-mermaid" data-language="mermaid"><code class="language-mermaid">sequenceDiagram张三 -&gt;&gt; 李四: 你好！李四, 最近怎么样?李四--&gt;&gt;王五: 你最近怎么样，王五？李四--x 张三: 我很好，谢谢!李四-x 王五: 我很好，谢谢!Note right of 王五: 李四想了很长时间, 文字太长了&lt;br&#x2F;&gt;不适合放在一行.李四--&gt;&gt;张三: 打量着王五...张三-&gt;&gt;王五: 很好... 王五, 你怎么样?<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这将产生一个流程图。:</p><pre class="line-numbers language-mermaid" data-language="mermaid"><code class="language-mermaid">graph LRA[长方形] -- 链接 --&gt; B((圆))A --&gt; C(圆角长方形)B --&gt; D&#123;菱形&#125;C --&gt; D<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>关于 <strong>Mermaid</strong> 语法，参考 <a href="https://mermaidjs.github.io/">这儿</a>,</li></ul><h2 id="FLowchart流程图"><a href="#FLowchart流程图" class="headerlink" title="FLowchart流程图"></a>FLowchart流程图</h2><p>我们依旧会支持flowchart的流程图：</p><pre class="line-numbers language-mermaid" data-language="mermaid"><code class="language-mermaid">flowchatst&#x3D;&gt;start: 开始e&#x3D;&gt;end: 结束op&#x3D;&gt;operation: 我的操作cond&#x3D;&gt;condition: 确认？st-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>关于 <strong>Flowchart流程图</strong> 语法，参考 <a href="http://adrai.github.io/flowchart.js/">这儿</a>.</li></ul><h2 id="导出与导入"><a href="#导出与导入" class="headerlink" title="导出与导入"></a>导出与导入</h2><h3 id="导出"><a href="#导出" class="headerlink" title="导出"></a>导出</h3><p>如果你想尝试使用此编辑器, 你可以在此篇文章任意编辑。当你完成了一篇文章的写作, 在上方工具栏找到 <strong>文章导出</strong> ，生成一个.md文件或者.html文件进行本地保存。</p><h3 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h3><p>如果你想加载一篇你写过的.md文件，在上方工具栏可以选择导入功能进行对应扩展名的文件导入，<br>继续你的创作。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>python基于协程的异步编程文档</title>
      <link href="2021/05/03/python-ji-yu-xie-cheng-de-yi-bu-bian-cheng-wen-dang/"/>
      <url>2021/05/03/python-ji-yu-xie-cheng-de-yi-bu-bian-cheng-wen-dang/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="协程-amp-异步编程-asyncio"><a href="#协程-amp-异步编程-asyncio" class="headerlink" title="协程 &amp; 异步编程(asyncio)"></a>协程 &amp; 异步编程(asyncio)</h1><p>协程不是计算机提供的，而是由程序员人为创造的。<br><strong>协程（Coroutine）</strong>,也可以被称为微线程，是一种用户态内的上下文切换技术，通俗地讲（讲人话:dog:)，协程就是通过一个线程实现代码块相互切换执行。<br>例如：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">def func1():print(1)    ...print(2)def func2():print(3)    ...print(4)func1()func2()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述代码是普通的函数定义和执行，按流程分别执行两个函数中的代码，并先后会输出：<code>1、2、3、4</code>。但如果介入协程技术那么就可以实现函数见代码切换执行，最终输入：<code>1、3、2、4</code> 。</p><h2 id="1-协程的实现"><a href="#1-协程的实现" class="headerlink" title="1. 协程的实现"></a>1. 协程的实现</h2><p>在Python中有多种方式可以实现协程，例如：</p><ul><li>greenlet，是一个第三方模块，用于实现协程代码（Gevent协程就是基于greenlet实现）</li><li>yield，生成器，借助生成器的特点也可以实现协程代码。</li><li>asyncio，在Python3.4中引入的模块用于编写协程代码。</li><li>async &amp; awiat，在Python3.5中引入的两个关键字，结合asyncio模块可以更方便的编写协程代码。</li></ul><h3 id="1-1-greenlet"><a href="#1-1-greenlet" class="headerlink" title="1.1 greenlet"></a>1.1 greenlet</h3><p>greentlet是一个第三方模块，需要提前安装 <code>pip3 install greenlet</code>才能使用。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">from greenlet import greenletdef func1():    print(1)        # 第1步：输出 1    gr2.switch()    # 第3步：切换到 func2 函数    print(2)        # 第6步：输出 2    gr2.switch()    # 第7步：切换到 func2 函数，从上一次执行的位置继续向后执行def func2():    print(3)        # 第4步：输出 3    gr1.switch()    # 第5步：切换到 func1 函数，从上一次执行的位置继续向后执行    print(4)        # 第8步：输出 4gr1 &#x3D; greenlet(func1)gr2 &#x3D; greenlet(func2)gr1.switch() # 第1步：去执行 func1 函数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：switch中也可以传递参数用于在切换执行时相互传递值。</p><h3 id="1-2-yield"><a href="#1-2-yield" class="headerlink" title="1.2 yield"></a>1.2 yield</h3><p>基于Python的生成器的yield和yield form关键字实现协程代码。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">def func1():    yield 1    yield from func2()    yield 2def func2():    yield 3    yield 4f1 &#x3D; func1()for item in f1:    print(item)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：yield form关键字是在Python3.3中引入的。</p><h3 id="1-3-asyncio"><a href="#1-3-asyncio" class="headerlink" title="1.3 asyncio"></a>1.3 asyncio</h3><p>在Python3.4之前官方未提供协程的类库，一般大家都是使用greenlet等其他来实现。在Python3.4发布后官方正式支持协程，即：asyncio模块。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import asyncio@asyncio.coroutinedef func1():    print(1)    yield from asyncio.sleep(2)  # 遇到IO耗时操作，自动化切换到tasks中的其他任务    print(2)@asyncio.coroutinedef func2():    print(3)    yield from asyncio.sleep(2) # 遇到IO耗时操作，自动化切换到tasks中的其他任务    print(4)tasks &#x3D; [    asyncio.ensure_future( func1() ),    asyncio.ensure_future( func2() )]loop &#x3D; asyncio.get_event_loop()loop.run_until_complete(asyncio.wait(tasks))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：基于asyncio模块实现的协程比之前的要更厉害，因为他的内部还集成了遇到IO耗时操作自动切花的功能。</p><h3 id="1-4-async-amp-awit"><a href="#1-4-async-amp-awit" class="headerlink" title="1.4 async &amp; awit"></a>1.4 async &amp; awit</h3><p>async &amp; awit 关键字在Python3.5版本中正式引入，基于他编写的协程代码其实就是 上一示例 的加强版，让代码可以更加简便。</p><p>Python3.8之后 <code>@asyncio.coroutine</code> 装饰器就会被移除，推荐使用async &amp; awit 关键字实现协程代码。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import asyncioasync def func1():    print(1)    await asyncio.sleep(2)    print(2)async def func2():    print(3)    await asyncio.sleep(2)    print(4)tasks &#x3D; [    asyncio.ensure_future(func1()),    asyncio.ensure_future(func2())]loop &#x3D; asyncio.get_event_loop()loop.run_until_complete(asyncio.wait(tasks))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-5-小结"><a href="#1-5-小结" class="headerlink" title="1.5 小结"></a>1.5 小结</h3><p>关于协程有多种实现方式，目前主流使用是Python官方推荐的asyncio模块和async&amp;await关键字的方式，例如：在tonado、sanic、fastapi、django3 中均已支持。</p><p>接下来，我们也会针对 <code>asyncio模块</code> + <code>async &amp; await</code> 关键字进行更加详细的讲解。</p><h2 id="2-协程的意义"><a href="#2-协程的意义" class="headerlink" title="2.协程的意义"></a>2.协程的意义</h2><p>通过学习，我们已经了解到协程可以通过一个线程在多个上下文中进行来回切换执行。</p><p><span><strong>但是</strong></span>，协程来回切换执行的意义何在呢？（网上看到很多文章舔协程，协程牛逼之处是哪里呢？）</p><pre class="line-numbers language-none"><code class="language-none">计算型的操作，利用协程来回切换执行，没有任何意义，来回切换并保存状态 反倒会降低性能。IO型的操作，利用协程在IO等待时间就去切换执行其他任务，当IO操作结束后再自动回调，那么就会大大节省资源并提供性能，从而实现异步编程（不等待任务结束就可以去执行其他代码）。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="2-1-爬虫案例"><a href="#2-1-爬虫案例" class="headerlink" title="2.1 爬虫案例"></a>2.1 爬虫案例</h3><p>例如：用代码实现下载 <code>url_list</code> 中的图片。</p><ul><li><p>方式一：同步编程实现</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">&quot;&quot;&quot;下载图片使用第三方模块requests，请提前安装：pip3 install requests&quot;&quot;&quot;import requestsdef download_image(url):print(&quot;开始下载:&quot;,url)    # 发送网络请求，下载图片    response &#x3D; requests.get(url)print(&quot;下载完成&quot;)    # 图片保存到本地文件    file_name &#x3D; url.rsplit(&#39;_&#39;)[-1]    with open(file_name, mode&#x3D;&#39;wb&#39;) as file_object:        file_object.write(response.content)if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    url_list &#x3D; [        &#39;https:&#x2F;&#x2F;www3.autoimg.cn&#x2F;newsdfs&#x2F;g26&#x2F;M02&#x2F;35&#x2F;A9&#x2F;120x90_0_autohomecar__ChsEe12AXQ6AOOH_AAFocMs8nzU621.jpg&#39;,        &#39;https:&#x2F;&#x2F;www2.autoimg.cn&#x2F;newsdfs&#x2F;g30&#x2F;M01&#x2F;3C&#x2F;E2&#x2F;120x90_0_autohomecar__ChcCSV2BBICAUntfAADjJFd6800429.jpg&#39;,        &#39;https:&#x2F;&#x2F;www3.autoimg.cn&#x2F;newsdfs&#x2F;g26&#x2F;M0B&#x2F;3C&#x2F;65&#x2F;120x90_0_autohomecar__ChcCP12BFCmAIO83AAGq7vK0sGY193.jpg&#39;    ]    for item in url_list:        download_image(item)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>方式二：基于协程的异步编程实现</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">&quot;&quot;&quot;下载图片使用第三方模块aiohttp，请提前安装：pip3 install aiohttp&quot;&quot;&quot;#!&#x2F;usr&#x2F;bin&#x2F;env python# -*- coding:utf-8 -*-import aiohttpimport asyncioasync def fetch(session, url):    print(&quot;发送请求：&quot;, url)    async with session.get(url, verify_ssl&#x3D;False) as response:        content &#x3D; await response.content.read()        file_name &#x3D; url.rsplit(&#39;_&#39;)[-1]        with open(file_name, mode&#x3D;&#39;wb&#39;) as file_object:            file_object.write(content)async def main():    async with aiohttp.ClientSession() as session:        url_list &#x3D; [            &#39;https:&#x2F;&#x2F;www3.autoimg.cn&#x2F;newsdfs&#x2F;g26&#x2F;M02&#x2F;35&#x2F;A9&#x2F;120x90_0_autohomecar__ChsEe12AXQ6AOOH_AAFocMs8nzU621.jpg&#39;,            &#39;https:&#x2F;&#x2F;www2.autoimg.cn&#x2F;newsdfs&#x2F;g30&#x2F;M01&#x2F;3C&#x2F;E2&#x2F;120x90_0_autohomecar__ChcCSV2BBICAUntfAADjJFd6800429.jpg&#39;,            &#39;https:&#x2F;&#x2F;www3.autoimg.cn&#x2F;newsdfs&#x2F;g26&#x2F;M0B&#x2F;3C&#x2F;65&#x2F;120x90_0_autohomecar__ChcCP12BFCmAIO83AAGq7vK0sGY193.jpg&#39;        ]        tasks &#x3D; [asyncio.create_task(fetch(session, url)) for url in url_list]        await asyncio.wait(tasks)if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    asyncio.run(main())<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>上述两种的执行对比之后会发现，<code>基于协程的异步编程</code> 要比 <code>同步编程</code>的效率高了很多。因为：</p><ul><li>同步编程，按照顺序逐一排队执行，如果图片下载时间为2分钟，那么全部执行完则需要6分钟。</li><li>异步编程，几乎同时发出了3个下载任务的请求（遇到IO请求自动切换去发送其他任务请求），如果图片下载时间为2分钟，那么全部执行完毕也大概需要2分钟左右就可以了。</li></ul><h3 id="2-2-小结"><a href="#2-2-小结" class="headerlink" title="2.2 小结"></a>2.2 小结</h3><p>协程一般应用在有IO操作的程序中，因为协程可以利用IO等待的时间去执行一些其他的代码，从而提升代码执行效率。</p><p>生活中不也是这样的么，假设 你是一家制造汽车的老板，员工点击设备的【开始】按钮之后，在设备前需等待30分钟，然后点击【结束】按钮，此时作为老板的你一定希望这个员工在等待的那30分钟的时间去做点其他的工作。</p><h2 id="3-异步编程"><a href="#3-异步编程" class="headerlink" title="3.异步编程"></a>3.异步编程</h2><p>基于<code>async</code> &amp; <code>await</code>关键字的协程可以实现异步编程，这也是目前python异步相关的主流技术。</p><p>想要真正的了解Python中内置的异步编程，根据下文的顺序一点点来看。</p><h3 id="3-1-事件循环"><a href="#3-1-事件循环" class="headerlink" title="3.1 事件循环"></a>3.1 事件循环</h3><p>事件循环，可以把他当做是一个while循环，这个while循环在周期性的运行并执行一些<code>任务</code>，在特定条件下终止循环。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 伪代码任务列表 &#x3D; [ 任务1, 任务2, 任务3,... ]while True:    可执行的任务列表，已完成的任务列表 &#x3D; 去任务列表中检查所有的任务，将&#39;可执行&#39;和&#39;已完成&#39;的任务返回        for 就绪任务 in 可执行的任务列表:        执行已就绪的任务            for 已完成的任务 in 已完成的任务列表:        在任务列表中移除 已完成的任务如果 任务列表 中的任务都已完成，则终止循环<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python">import asyncio# 去生成或获取一个事件循环loop &#x3D; asyncio.get_event_loop()# 将任务放到&#96;任务列表&#96;loop.run_until_complete(任务)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在编写程序时候可以通过如下代码来获取和创建事件循环。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import asyncioloop &#x3D; asyncio.get_event_loop()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="3-2-协程和异步编程"><a href="#3-2-协程和异步编程" class="headerlink" title="3.2 协程和异步编程"></a>3.2 协程和异步编程</h3><p>协程函数，定义形式为 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#async-def"><code>async def</code></a> 的函数。</p><p>协程对象，调用 <em>协程函数</em> 所返回的对象。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 定义一个协程函数async def func():    pass# 调用协程函数，返回一个协程对象result &#x3D; func()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意</strong>：调用协程函数时，函数内部代码不会执行，只是会返回一个协程对象。</p><h4 id="3-2-1-基本应用"><a href="#3-2-1-基本应用" class="headerlink" title="3.2.1 基本应用"></a>3.2.1 基本应用</h4><p>程序中，如果想要执行协程函数的内部代码，需要 <code>事件循环</code> 和 <code>协程对象</code> 配合才能实现，如：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import asyncioasync def func():    print(&quot;协程内部代码&quot;)    # 调用协程函数，返回一个协程对象。    result &#x3D; func()    # 方式一#     loop &#x3D; asyncio.get_event_loop()     # 创建一个事件循环#     loop.run_until_complete(result)     # 将协程当做任务提交到事件循环的任务列表中，协程执行完成之后终止。    # 方式二    # 本质上方式一是一样的，内部先 创建事件循环 然后执行 run_until_complete，一个简便的写法。    # asyncio.run 函数在 Python 3.7 中加入 asyncio 模块    asyncio.run(result)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个过程可以简单理解为：将<code>协程</code>当做任务添加到 <code>事件循环</code> 的任务列表，然后事件循环检测列表中的<code>协程</code>是否 已准备就绪（默认可理解为就绪状态），如果准备就绪则执行其内部代码。</p><h4 id="3-2-2-await"><a href="#3-2-2-await" class="headerlink" title="3.2.2 await"></a>3.2.2 await</h4><p>await是一个只能在协程函数中使用的关键字，用于遇到IO操作时挂起 当前协程（任务），当前协程（任务）挂起过程中 事件循环可以去执行其他的协程（任务），当前协程IO处理完成时，可以再次切换回来执行await之后的代码。代码如下：</p><p><strong>示例1：</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import asyncioasync def func():    print(&quot;执行协程函数内部代码&quot;)        # 遇到IO操作挂起当前协程（任务），等IO操作完成之后再继续往下执行。        # 当前协程挂起时，事件循环可以去执行其他协程（任务）。    response &#x3D; await asyncio.sleep(2)    print(&quot;IO请求结束，结果为：&quot;, response)    result &#x3D; func()asyncio.run(result)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例2：</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import asyncioasync def others():    print(&quot;start&quot;)    await asyncio.sleep(2)    print(&#39;end&#39;)    return &#39;返回值&#39;async def func():    print(&quot;执行协程函数内部代码&quot;)        # 遇到IO操作挂起当前协程（任务），等IO操作完成之后再继续往下执行。当前协程挂起时，事件循环可以去执行其他协程（任务）。    response &#x3D; await others()        print(&quot;IO请求结束，结果为：&quot;, response)    asyncio.run( func() )<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例3：</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import asyncioasync def others():    print(&quot;start&quot;)    await asyncio.sleep(2)    print(&#39;end&#39;)    return &#39;返回值&#39;async def func():    print(&quot;执行协程函数内部代码&quot;)        # 遇到IO操作挂起当前协程（任务），等IO操作完成之后再继续往下执行。当前协程挂起时，事件循环可以去执行其他协程（任务）。    response1 &#x3D; await others()    print(&quot;IO请求结束，结果为：&quot;, response1)          response2 &#x3D; await others()    print(&quot;IO请求结束，结果为：&quot;, response2)     asyncio.run( func() )<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述的所有示例都只是创建了一个任务，即：事件循环的任务列表中只有一个任务，所以在IO等待时无法演示切换到其他任务效果。</p><p>在程序想要创建多个任务对象，需要使用Task对象来实现。</p><h4 id="3-2-3-Task对象"><a href="#3-2-3-Task对象" class="headerlink" title="3.2.3 Task对象"></a>3.2.3 Task对象</h4><blockquote><p><em>Tasks</em> are used to schedule coroutines <em>concurrently</em>.</p><p>When a coroutine is wrapped into a <em>Task</em> with functions like <a href="https://docs.python.org/3.8/library/asyncio-task.html#asyncio.create_task"><code>asyncio.create_task()</code></a> the coroutine is automatically scheduled to run soon。</p></blockquote><p>Tasks用于并发调度协程，通过<code>asyncio.create_task(协程对象)</code>的方式创建Task对象，这样可以让协程加入事件循环中等待被调度执行。除了使用 <code>asyncio.create_task()</code> 函数以外，还可以用低层级的 <code>loop.create_task()</code> 或 <code>ensure_future()</code> 函数。不建议手动实例化 Task 对象。</p><p>本质上是将协程对象封装成task对象，并将协程立即加入事件循环，同时追踪协程的状态。</p><p>注意：<code>asyncio.create_task()</code> 函数在 Python 3.7 中被加入。在 Python 3.7 之前，可以改用低层级的 <code>asyncio.ensure_future()</code> 函数。</p><p><strong>示例1：</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import asyncioasync def func():    print(1)    await asyncio.sleep(2)    print(2)    return &quot;返回值&quot;async def main():    print(&quot;main开始&quot;)        # 创建协程，将协程封装到一个Task对象中并立即添加到事件循环的任务列表中，等待事件循环去执行（默认是就绪状态）。    task1 &#x3D; asyncio.create_task(func())   # 创建协程，将协程封装到一个Task对象中并立即添加到事件循环的任务列表中，等待事件循环去执行（默认是就绪状态）。    task2 &#x3D; asyncio.create_task(func())        print(&quot;main结束&quot;)        # 当执行某协程遇到IO操作时，会自动化切换执行其他任务。    # 此处的await是等待相对应的协程全都执行完毕并获取结果    ret1 &#x3D; await task1    ret2 &#x3D; await task2    print(ret1, ret2)asyncio.run(main())<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例2：</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import asyncioasync def func():    print(1)    await asyncio.sleep(2)    print(2)    return &quot;返回值&quot;async def main():    print(&quot;main开始&quot;)        # 创建协程，将协程封装到Task对象中并添加到事件循环的任务列表中，等待事件循环去执行（默认是就绪状态）。    # 在调用    task_list &#x3D; [                asyncio.create_task(func(), name&#x3D;&quot;n1&quot;),        asyncio.create_task(func(), name&#x3D;&quot;n2&quot;)    ]        print(&quot;main结束&quot;)    # 当执行某协程遇到IO操作时，会自动化切换执行其他任务。    # 此处的await是等待所有协程执行完毕，并将所有协程的返回值保存到done    # 如果设置了timeout值，则意味着此处最多等待的秒，完成的协程返回值写入到done中，未完成则写到pending中。    done, pending &#x3D; await asyncio.wait(task_list, timeout&#x3D;None)    print(done, pending)    asyncio.run(main())<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：<code>asyncio.wait</code> 源码内部会对列表中的每个协程执行ensure_future从而封装为Task对象，所以在和wait配合使用时task_list的值为<code>[func(),func()]</code> 也是可以的。</p><p><strong>示例3：</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import asyncioasync def func():    print(&quot;执行协程函数内部代码&quot;)    # 遇到IO操作挂起当前协程（任务），等IO操作完成之后再继续往下执行。当前协程挂起时，事件循环可以去执行其他协程（任务）。    response &#x3D; await asyncio.sleep(2)    print(&quot;IO请求结束，结果为：&quot;, response)        coroutine_list &#x3D; [func(), func()]# 错误：#coroutine_list &#x3D; [ #    asyncio.create_task(func()), #    asyncio.create_task(func())#]  # 此处不能直接 asyncio.create_task，因为将Task立即加入到事件循环的任务列表，# 但此时事件循环还未创建，所以会报错。# 使用asyncio.wait将列表封装为一个协程，并调用asyncio.run实现执行两个协程# asyncio.wait内部会对列表中的每个协程执行ensure_future，封装为Task对象。done,pending &#x3D; asyncio.run(asyncio.wait(coroutine_list) )print(done)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-2-4-asyncio-Future对象"><a href="#3-2-4-asyncio-Future对象" class="headerlink" title="3.2.4 asyncio.Future对象"></a>3.2.4 asyncio.Future对象</h4><blockquote><p>A <code>Future</code>is a special <strong>low-level</strong> awaitable object that represents an <strong>eventual result</strong> of an asynchronous operation.</p></blockquote><p>asyncio中的Future对象是一个相对更偏向底层的可对象，通常我们不会直接用到这个对象，而是直接使用Task对象来完成任务的并和状态的追踪。（ Task 是 Futrue的子类 ）</p><p>Future为我们提供了异步编程中的 最终结果 的处理（Task类也具备状态处理的功能）。</p><p>示例1：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">async def main():    # 获取当前事件循环    loop &#x3D; asyncio.get_running_loop()        # # 创建一个任务（Future对象），这个任务什么都不干。    fut &#x3D; loop.create_future()        # 等待任务最终结果（Future对象），没有结果则会一直等下去。    await fut    asyncio.run(main())<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>示例2：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import asyncioasync def set_after(fut):    await asyncio.sleep(2)    fut.set_result(&quot;666&quot;)    async def main():        # 获取当前事件循环        loop &#x3D; asyncio.get_running_loop()                # 创建一个任务（Future对象），没绑定任何行为，则这个任务永远不知道什么时候结束。        fut &#x3D; loop.create_future()                # 创建一个任务（Task对象），绑定了set_after函数，函数内部在2s之后，会给fut赋值。        # 即手动设置future任务的最终结果，那么fut就可以结束了。        await loop.create_task(set_after(fut))                # 等待 Future对象获取 最终结果，否则一直等下去        data &#x3D; await fut        print(data)        asyncio.run(main())<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Future对象本身函数进行绑定，所以想要让事件循环获取Future的结果，则需要手动设置。而Task对象继承了Future对象，其实就对Future进行扩展，他可以实现在对应绑定的函数执行完成之后，自动执行<code>set_result</code>，从而实现自动结束。</p><p>虽然，平时使用的是Task对象，但对于结果的处理本质是基于Future对象来实现的。</p><p>扩展：支持 <code>await 对象</code>语 法的对象课成为可等待对象，所以 <code>协程对象</code>、<code>Task对象</code>、<code>Future对象</code> 都可以被成为可等待对象。</p><h4 id="3-2-5-futures-Future对象"><a href="#3-2-5-futures-Future对象" class="headerlink" title="3.2.5 futures.Future对象"></a>3.2.5 futures.Future对象</h4><p>在Python的<code>concurrent.futures</code>模块中也有一个Future对象，这个对象是基于线程池和进程池实现异步操作时使用的对象。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import timefrom concurrent.futures import Futurefrom concurrent.futures.thread import ThreadPoolExecutorfrom concurrent.futures.process import ProcessPoolExecutordef func(value):    time.sleep(1)    print(value)    pool &#x3D; ThreadPoolExecutor(max_workers&#x3D;5)# 或 # pool &#x3D; ProcessPoolExecutor(max_workers&#x3D;5)        for i in range(10):        fut &#x3D; pool.submit(func, i)        print(fut)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>两个Future对象是不同的，他们是为不同的应用场景而设计，例如：<code>concurrent.futures.Future</code>不支持await语法 等。</p><p>官方提示两对象之间不同：</p><ul><li><p>unlike asyncio Futures, <a href="https://docs.python.org/3.8/library/concurrent.futures.html#concurrent.futures.Future"><code>concurrent.futures.Future</code></a> instances cannot be awaited.</p></li><li><p><a href="https://docs.python.org/3.8/library/asyncio-future.html#asyncio.Future.result"><code>asyncio.Future.result()</code></a> and <a href="https://docs.python.org/3.8/library/asyncio-future.html#asyncio.Future.exception"><code>asyncio.Future.exception()</code></a> do not accept the <em>timeout</em> argument.</p></li><li><p><a href="https://docs.python.org/3.8/library/asyncio-future.html#asyncio.Future.result"><code>asyncio.Future.result()</code></a> and <a href="https://docs.python.org/3.8/library/asyncio-future.html#asyncio.Future.exception"><code>asyncio.Future.exception()</code></a> raise an <a href="https://docs.python.org/3.8/library/asyncio-exceptions.html#asyncio.InvalidStateError"><code>InvalidStateError</code></a> exception when the Future is not <em>done</em>.</p></li><li><p>Callbacks registered with <a href="https://docs.python.org/3.8/library/asyncio-future.html#asyncio.Future.add_done_callback"><code>asyncio.Future.add_done_callback()</code></a> are not called immediately. They are scheduled with <a href="https://docs.python.org/3.8/library/asyncio-eventloop.html#asyncio.loop.call_soon"><code>loop.call_soon()</code></a> instead.</p></li><li><p>asyncio Future is not compatible with the <a href="https://docs.python.org/3.8/library/concurrent.futures.html#concurrent.futures.wait"><code>concurrent.futures.wait()</code></a> and <a href="https://docs.python.org/3.8/library/concurrent.futures.html#concurrent.futures.as_completed"><code>concurrent.futures.as_completed()</code></a> functions.</p></li></ul><p>在Python提供了一个将<code>futures.Future</code> 对象包装成<code>asyncio.Future</code>对象的函数 <code>asynic.wrap_future</code>。</p><p>接下里你肯定问：为什么python会提供这种功能？</p><p>其实，一般在程序开发中我们要么统一使用 asycio 的协程实现异步操作、要么都使用进程池和线程池实现异步操作。但如果 <code>协程的异步</code>和 <code>进程池/线程池的异步</code> 混搭时，那么就会用到此功能了。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import timeimport asyncioimport concurrent.futuresdef func1():    # 某个耗时操作    time.sleep(2)    return &quot;SB&quot;async def main():    loop &#x3D; asyncio.get_running_loop()        # 1. Run in the default loop&#39;s executor ( 默认ThreadPoolExecutor )    # 第一步：内部会先调用 ThreadPoolExecutor 的 submit 方法去线程池中申请一个线程去执行func1函数，并返回一个concurrent.futures.Future对象    # 第二步：调用asyncio.wrap_future将concurrent.futures.Future对象包装为asycio.Future对象。    # 因为concurrent.futures.Future对象不支持await语法，所以需要包装为 asycio.Future对象 才能使用。    fut &#x3D; loop.run_in_executor(None, func1)    result &#x3D; await fut    print(&#39;default thread pool&#39;, result)        # 2. Run in a custom thread pool:    # with concurrent.futures.ThreadPoolExecutor() as pool:    #     result &#x3D; await loop.run_in_executor(    #         pool, func1)    #     print(&#39;custom thread pool&#39;, result)        # 3. Run in a custom process pool:    # with concurrent.futures.ProcessPoolExecutor() as pool:    #     result &#x3D; await loop.run_in_executor(    #         pool, func1)    #     print(&#39;custom process pool&#39;, result)    asyncio.run(main())<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>应用场景：当项目以协程式的异步编程开发时，如果要使用一个第三方模块，而第三方模块不支持协程方式异步编程时，就需要用到这个功能，例如：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import asyncioimport requestsasyncdef download_image(url):    # 发送网络请求，下载图片（遇到网络下载图片的IO请求，自动化切换到其他任务）    print(&quot;开始下载:&quot;, url)        loop &#x3D; asyncio.get_event_loop()    # requests模块默认不支持异步操作，所以就使用线程池来配合实现了。    future &#x3D; loop.run_in_executor(None, requests.get, url)        response &#x3D; await future    print(&#39;下载完成&#39;)    # 图片保存到本地文件    file_name &#x3D; url.rsplit(&#39;_&#39;)[-1]    with open(file_name, mode&#x3D;&#39;wb&#39;) as file_object:        file_object.write(response.content)        if __name__ &#x3D;&#x3D; &#39;__main__&#39;:     url_list &#x3D; [                &#39;https:&#x2F;&#x2F;www3.autoimg.cn&#x2F;newsdfs&#x2F;g26&#x2F;M02&#x2F;35&#x2F;A9&#x2F;120x90_0_autohomecar__ChsEe12AXQ6AOOH_AAFocMs8nzU621.jpg&#39;,                &#39;https:&#x2F;&#x2F;www2.autoimg.cn&#x2F;newsdfs&#x2F;g30&#x2F;M01&#x2F;3C&#x2F;E2&#x2F;120x90_0_autohomecar__ChcCSV2BBICAUntfAADjJFd6800429.jpg&#39;,                &#39;https:&#x2F;&#x2F;www3.autoimg.cn&#x2F;newsdfs&#x2F;g26&#x2F;M0B&#x2F;3C&#x2F;65&#x2F;120x90_0_autohomecar__ChcCP12BFCmAIO83AAGq7vK0sGY193.jpg&#39;    ]    tasks &#x3D; [download_image(url) for url in url_list]         loop &#x3D; asyncio.get_event_loop()       loop.run_until_complete( asyncio.wait(tasks) )<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-2-6-异步迭代器"><a href="#3-2-6-异步迭代器" class="headerlink" title="3.2.6 异步迭代器"></a>3.2.6 异步迭代器</h4><p><strong>什么是异步迭代器</strong></p><p>实现了 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__aiter__"><code>__aiter__()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__anext__"><code>__anext__()</code></a> 方法的对象。<code>__anext__</code> 必须返回一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-awaitable">awaitable</a> 对象。<a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#async-for"><code>async for</code></a> 会处理异步迭代器的 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__anext__"><code>__anext__()</code></a> 方法所返回的可等待对象，直到其引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#StopAsyncIteration"><code>StopAsyncIteration</code></a> 异常。由 <a href="https://www.python.org/dev/peps/pep-0492"><strong>PEP 492</strong></a> 引入。</p><p><strong>什么是异步可迭代对象？</strong></p><p>可在 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#async-for"><code>async for</code></a> 语句中被使用的对象。必须通过它的 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__aiter__"><code>__aiter__()</code></a> 方法返回一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-asynchronous-iterator">asynchronous iterator</a>。由 <a href="https://www.python.org/dev/peps/pep-0492"><strong>PEP 492</strong></a> 引入。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import asyncioclass Reader(object):    &quot;&quot;&quot; 自定义异步迭代器（同时也是异步可迭代对象） &quot;&quot;&quot;        def __init__(self):        self.count &#x3D; 0            async def readline(self):        # await asyncio.sleep(1)        self.count +&#x3D; 1        if self.count &#x3D;&#x3D; 100:            return None        return self.count            def __aiter__(self):        return self            async def __anext__(self):        val &#x3D; await self.readline()        if val &#x3D;&#x3D; None:            raise StopAsyncIteration        return val            async def func():              # 创建异步可迭代对象        async_iter &#x3D; Reader()        # async for 必须要放在async def函数内，否则语法错误。        async for item in async_iter:            print(item)            asyncio.run(func())<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>异步迭代器其实没什么太大的作用，只是支持了async for语法而已。</p><h4 id="3-2-6-异步上下文管理器"><a href="#3-2-6-异步上下文管理器" class="headerlink" title="3.2.6 异步上下文管理器"></a>3.2.6 异步上下文管理器</h4><p>此种对象通过定义 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__aenter__"><code>__aenter__()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__aexit__"><code>__aexit__()</code></a> 方法来对 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#async-with"><code>async with</code></a> 语句中的环境进行控制。由 <a href="https://www.python.org/dev/peps/pep-0492"><strong>PEP 492</strong></a> 引入。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import asyncioclass AsyncContextManager:    def __init__(self):                self.conn &#x3D; conn                async def do_something(self):                    # 异步操作数据库                    return 666                    async def __aenter__(self):                    # 异步链接数据库            self.conn &#x3D; await asyncio.sleep(1)                    return self                  async def __aexit__(self, exc_type, exc, tb):               # 异步关闭数据库链接            await asyncio.sleep(1)            async def func():        async with AsyncContextManager() as f:                result &#x3D; await f.do_something()                    print(result)asyncio.run(func())        asyncio.run( func() )<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个异步的上下文管理器还是比较有用的，平时在开发过程中 打开、处理、关闭 操作时，就可以用这种方式来处理。</p><h3 id="3-3-小结"><a href="#3-3-小结" class="headerlink" title="3.3 小结"></a>3.3 小结</h3><p>在程序中只要看到<code>async</code>和<code>await</code>关键字，其内部就是基于协程实现的异步编程，这种异步编程是通过一个线程在IO等待时间去执行其他任务，从而实现并发。</p><p>以上就是异步编程的常见操作，内容参考官方文档。</p><ul><li>中文版：<a href="https://docs.python.org/zh-cn/3.8/library/asyncio.html">https://docs.python.org/zh-cn/3.8/library/asyncio.html</a></li><li>英文本：<a href="https://docs.python.org/3.8/library/asyncio.html">https://docs.python.org/3.8/library/asyncio.html</a></li></ul><h2 id="4-uvloop"><a href="#4-uvloop" class="headerlink" title="4. uvloop"></a>4. uvloop</h2><p>Python标准库中提供了<code>asyncio</code>模块，用于支持基于协程的异步编程。</p><p>uvloop是 asyncio 中的事件循环的替代方案，替换后可以使得asyncio性能提高。事实上，uvloop要比nodejs、gevent等其他python异步框架至少要快2倍，性能可以比肩Go语言。</p><p>安装uvloop</p><pre class="line-numbers language-none"><code class="language-none">pip3 install uvloop<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在项目中想要使用uvloop替换asyncio的事件循环也非常简单，只要在代码中这么做就行。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import asyncioimport uvloopasyncio.set_event_loop_policy(uvloop.EventLoopPolicy())# 编写asyncio的代码，与之前写的代码一致。# 内部的事件循环自动化会变为uvloopasyncio.run(...)asyncio.run(...)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：知名的asgi uvicorn内部就是使用的uvloop的事件循环。</p><h2 id="5-实战案例"><a href="#5-实战案例" class="headerlink" title="5.实战案例"></a>5.实战案例</h2><p>为了更好理解，上述所有示例的IO情况都是以 <code>asyncio.sleep</code> 为例，而真实的项目开发中会用到很多IO的情况。</p><h3 id="5-1-异步Redis"><a href="#5-1-异步Redis" class="headerlink" title="5.1 异步Redis"></a>5.1 异步Redis</h3><p>当通过python去操作redis时，链接、设置值、获取值 这些都涉及网络IO请求，使用asycio异步的方式可以在IO等待时去做一些其他任务，从而提升性能。</p><p>安装Python异步操作redis模块</p><pre class="line-numbers language-none"><code class="language-none">pip3 install aioredis<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>示例1：异步操作redis。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">#!&#x2F;usr&#x2F;bin&#x2F;env python# -*- coding:utf-8 -*-import asyncioimport aioredisasync def execute(address, password):    print(&quot;开始执行&quot;, address)    # 网络IO操作：创建redis连接    redis &#x3D; await aioredis.create_redis(address, password&#x3D;password)    # 网络IO操作：在redis中设置哈希值car，内部在设三个键值对，即： redis &#x3D; &#123; car:&#123;key1:1,key2:2,key3:3&#125;&#125;    await redis.hmset_dict(&#39;car&#39;, key1&#x3D;1, key2&#x3D;2, key3&#x3D;3)    # 网络IO操作：去redis中获取值    result &#x3D; await redis.hgetall(&#39;car&#39;, encoding&#x3D;&#39;utf-8&#39;)    print(result)    redis.close()    # 网络IO操作：关闭redis连接    await redis.wait_closed()    print(&quot;结束&quot;, address)asyncio.run( execute(&#39;redis:&#x2F;&#x2F;47.93.4.198:6379&#39;, &quot;root!2345&quot;) )<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>示例2：连接多个redis做操作（遇到IO会切换其他任务，提供了性能）。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import asyncioimport aioredisasync def execute(address, password):    print(&quot;开始执行&quot;, address)    # 网络IO操作：先去连接 47.93.4.197:6379，遇到IO则自动切换任务，去连接47.93.4.198:6379    redis &#x3D; await aioredis.create_redis_pool(address, password&#x3D;password)    # 网络IO操作：遇到IO会自动切换任务    await redis.hmset_dict(&#39;car&#39;, key1&#x3D;1, key2&#x3D;2, key3&#x3D;3)    # 网络IO操作：遇到IO会自动切换任务    result &#x3D; await redis.hgetall(&#39;car&#39;, encoding&#x3D;&#39;utf-8&#39;)    print(result)    redis.close()    # 网络IO操作：遇到IO会自动切换任务    await redis.wait_closed()    print(&quot;结束&quot;, address)task_list &#x3D; [    execute(&#39;redis:&#x2F;&#x2F;47.93.4.197:6379&#39;, &quot;root!2345&quot;),    execute(&#39;redis:&#x2F;&#x2F;47.93.4.198:6379&#39;, &quot;root!2345&quot;)]asyncio.run(asyncio.wait(task_list))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>更多redis操作参考aioredis官网：<a href="https://aioredis.readthedocs.io/en/v1.3.0/start.html">https://aioredis.readthedocs.io/en/v1.3.0/start.html</a></p><h3 id="5-2-异步MySQL"><a href="#5-2-异步MySQL" class="headerlink" title="5.2 异步MySQL"></a>5.2 异步MySQL</h3><p>当通过python去操作MySQL时，连接、执行SQL、关闭都涉及网络IO请求，使用asycio异步的方式可以在IO等待时去做一些其他任务，从而提升性能。</p><p>安装Python异步操作redis模块</p><pre class="line-numbers language-none"><code class="language-none">pip3 install aiomysql<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>示例1：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import asyncioimport aiomysqlasync def execute():    # 网络IO操作：连接MySQL    conn &#x3D; await aiomysql.connect(host&#x3D;&#39;127.0.0.1&#39;, port&#x3D;3306, user&#x3D;&#39;root&#39;, password&#x3D;&#39;123&#39;, db&#x3D;&#39;mysql&#39;, )    # 网络IO操作：创建CURSOR    cur &#x3D; await conn.cursor()    # 网络IO操作：执行SQL    await cur.execute(&quot;SELECT Host,User FROM user&quot;)    # 网络IO操作：获取SQL结果    result &#x3D; await cur.fetchall()    print(result)    # 网络IO操作：关闭链接    await cur.close()    conn.close()asyncio.run(execute())<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>示例2：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">#!&#x2F;usr&#x2F;bin&#x2F;env python# -*- coding:utf-8 -*-import asyncioimport aiomysqlasync def execute(host, password):    print(&quot;开始&quot;, host)    # 网络IO操作：先去连接 47.93.40.197，遇到IO则自动切换任务，去连接47.93.40.198:6379    conn &#x3D; await aiomysql.connect(host&#x3D;host, port&#x3D;3306, user&#x3D;&#39;root&#39;, password&#x3D;password, db&#x3D;&#39;mysql&#39;)    # 网络IO操作：遇到IO会自动切换任务    cur &#x3D; await conn.cursor()    # 网络IO操作：遇到IO会自动切换任务    await cur.execute(&quot;SELECT Host,User FROM user&quot;)    # 网络IO操作：遇到IO会自动切换任务    result &#x3D; await cur.fetchall()    print(result)    # 网络IO操作：遇到IO会自动切换任务    await cur.close()    conn.close()    print(&quot;结束&quot;, host)task_list &#x3D; [    execute(&#39;47.93.41.197&#39;, &quot;root!2345&quot;),    execute(&#39;47.93.40.197&#39;, &quot;root!2345&quot;)]asyncio.run(asyncio.wait(task_list))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-3-FastAPI框架"><a href="#5-3-FastAPI框架" class="headerlink" title="5.3 FastAPI框架"></a>5.3 FastAPI框架</h3><p>FastAPI是一款用于构建API的高性能web框架，框架基于Python3.6+的 <code>type hints</code>搭建。</p><p>接下里的异步示例以<code>FastAPI</code>和<code>uvicorn</code>来讲解（uvicorn是一个支持异步的asgi）。</p><p>安装FastAPI web 框架，</p><pre class="line-numbers language-none"><code class="language-none">pip3 install fastapi<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>安装uvicorn，本质上为web提供socket server的支持的asgi（一般支持异步称asgi、不支持异步称wsgi）</p><pre class="line-numbers language-none"><code class="language-none">pip3 install uvicorn<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">#!&#x2F;usr&#x2F;bin&#x2F;env python# -*- coding:utf-8 -*-import asyncioimport uvicornimport aioredisfrom aioredis import Redisfrom fastapi import FastAPIapp &#x3D; FastAPI()# 创建一个redis连接池REDIS_POOL &#x3D; aioredis.ConnectionsPool(&#39;redis:&#x2F;&#x2F;47.193.14.198:6379&#39;, password&#x3D;&quot;root123&quot;, minsize&#x3D;1, maxsize&#x3D;10)@app.get(&quot;&#x2F;&quot;)def index():    &quot;&quot;&quot; 普通操作接口 &quot;&quot;&quot;    return &#123;&quot;message&quot;: &quot;Hello World&quot;&#125;@app.get(&quot;&#x2F;red&quot;)async def red():    &quot;&quot;&quot; 异步操作接口 &quot;&quot;&quot;        print(&quot;请求来了&quot;)    await asyncio.sleep(3)    # 连接池获取一个连接    conn &#x3D; await REDIS_POOL.acquire()    redis &#x3D; Redis(conn)    # 设置值    await redis.hmset_dict(&#39;car&#39;, key1&#x3D;1, key2&#x3D;2, key3&#x3D;3)    # 读取值    result &#x3D; await redis.hgetall(&#39;car&#39;, encoding&#x3D;&#39;utf-8&#39;)    print(result)    # 连接归还连接池    REDIS_POOL.release(conn)    return resultif __name__ &#x3D;&#x3D; &#39;__main__&#39;:    uvicorn.run(&quot;luffy:app&quot;, host&#x3D;&quot;127.0.0.1&quot;, port&#x3D;5000, log_level&#x3D;&quot;info&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在有多个用户并发请求的情况下，异步方式来编写的接口可以在IO等待过程中去处理其他的请求，提供性能。</p><p>例如：同时有两个用户并发来向接口 <code>http://127.0.0.1:5000/red</code> 发送请求，服务端只有一个线程，同一时刻只有一个请求被处理。  异步处理可以提供并发是因为：当视图函数在处理第一个请求时，第二个请求此时是等待被处理的状态，当第一个请求遇到IO等待时，会自动切换去接收并处理第二个请求，当遇到IO时自动化切换至其他请求，一旦有请求IO执行完毕，则会再次回到指定请求向下继续执行其功能代码。</p><h3 id="5-4-爬虫"><a href="#5-4-爬虫" class="headerlink" title="5.4 爬虫"></a>5.4 爬虫</h3><p>在编写爬虫应用时，需要通过网络IO去请求目标数据，这种情况适合使用异步编程来提升性能，接下来我们使用支持异步编程的aiohttp模块来实现。</p><p>安装aiohttp模块</p><pre class="line-numbers language-none"><code class="language-none">pip3 install aiohttp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import aiohttpimport asyncioasync def fetch(session, url):    print(&quot;发送请求：&quot;, url)    async with session.get(url, verify_ssl&#x3D;False) as response:        text &#x3D; await response.text()        print(&quot;得到结果：&quot;, url, len(text))        return textasync def main():    async with aiohttp.ClientSession() as session:        url_list &#x3D; [            &#39;https:&#x2F;&#x2F;python.org&#39;,            &#39;https:&#x2F;&#x2F;www.baidu.com&#39;,            &#39;https:&#x2F;&#x2F;www.pythonav.com&#39;        ]        tasks &#x3D; [ asyncio.create_task(fetch(session, url)) for url in url_list]        done,pending &#x3D; await asyncio.wait(tasks)if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    asyncio.run( main() )<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>为了提升性能越来越多的框架都在向异步编程靠拢，例如：sanic、tornado、django3.0、django channels组件 等，用更少资源可以做处理更多的事，何乐而不为呢。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>清华pip镜像</title>
      <link href="2021/04/10/qing-hua-pip-jing-xiang/"/>
      <url>2021/04/10/qing-hua-pip-jing-xiang/</url>
      
        <content type="html"><![CDATA[<h1 id="清华pip镜像使用方法"><a href="#清华pip镜像使用方法" class="headerlink" title="清华pip镜像使用方法"></a>清华pip镜像使用方法</h1><p>pip install -i <a href="https://pypi.tuna.tsinghua.edu.cn/simple">https://pypi.tuna.tsinghua.edu.cn/simple</a> xxx<br>xxx表示的是第三方库的名字</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
